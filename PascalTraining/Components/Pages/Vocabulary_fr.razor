@page "/vocabulary_fr"

@using Microsoft.Extensions.Localization
@using System.Globalization;

@rendermode InteractiveServer

<PageTitle>Vocabulary</PageTitle>

<p class="h2 text-center">Vocabulary</p>
<p>&nbsp;</p>
<p class="h4">
    Voici un peu de vocabulaire pour vous aider à comprendre les termes utilisés dans ce tutoriel.
</p>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire du Développement de Site Web</h1>

    <div class="accordion">
        <!-- Section HTML -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#htmlSection" 
                aria-expanded="false" aria-controls="htmlSection">
                    HTML (HyperText Markup Language)
                </button>
            </h2>
            <div id="htmlSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>&lt;html&gt;</strong> : Élément racine d'un document HTML (contient tous les autres éléments HTML). Il encapsule tout le contenu HTML de la page et doit contenir deux éléments principaux : <code>&lt;head&gt;</code> et <code>&lt;body&gt;</code>. Exemple :
                            <pre>
                            <code>
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Titre de la page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;Contenu de la page&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;head&gt;</strong> : Métadonnées du document (contient des informations comme le titre, les liens vers les feuilles de style, les scripts, etc.). Les métadonnées incluent des informations comme le jeu de caractères, les auteurs du document, et les instructions pour les moteurs de recherche. Exemple :
                            <pre>
                            <code>
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;title&gt;Titre de la page&lt;/title&gt;
&lt;link rel="stylesheet" href="styles.css"&gt;
&lt;/head&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;body&gt;</strong> : Contenu visible de la page (contient tous les éléments visibles par l'utilisateur, comme les paragraphes, les images, les liens, etc.). C'est dans cet élément que vous placez les balises HTML qui définissent la structure et le contenu de la page. Exemple :
                            <pre>
                            <code>
&lt;body&gt;
&lt;h1&gt;Bienvenue&lt;/h1&gt;
&lt;p&gt;Ceci est un paragraphe de texte.&lt;/p&gt;
&lt;img src="image.jpg" alt="Description de l'image"&gt;
&lt;/body&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;h1&gt; à &lt;h6&gt;</strong> : Titres de niveaux (utilisés pour définir des titres, <code>&lt;h1&gt;</code> étant le plus important et <code>&lt;h6&gt;</code> le moins important). Les titres sont utilisés pour structurer le contenu et améliorer la lisibilité. Exemple :
                            <pre>
                            <code>
&lt;h1&gt;Titre Principal&lt;/h1&gt;
&lt;h2&gt;Sous-titre&lt;/h2&gt;
&lt;h3&gt;Sous-sous-titre&lt;/h3&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;p&gt;</strong> : Paragraphe (utilisé pour définir un bloc de texte). Chaque paragraphe est automatiquement séparé par un espace vertical, ce qui améliore la lisibilité du texte. Exemple :
                            <pre>
                            <code>
&lt;p&gt;Ceci est un paragraphe de texte.&lt;/p&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;a&gt;</strong> : Lien hypertexte (utilisé pour créer des liens vers d'autres pages ou ressources). L'attribut <code>href</code> définit l'URL de destination. Exemple :
                            <pre>
                            <code>
&lt;a href="https://example.com"&gt;Visitez Example&lt;/a&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;img&gt;</strong> : Image (utilisé pour afficher des images sur la page, nécessite l'attribut <code>src</code> pour spécifier la source de l'image). L'attribut <code>alt</code> fournit une description alternative pour les lecteurs d'écran et les cas où l'image ne peut pas être affichée. Exemple :
                            <pre>
                            <code>
&lt;img src="image.jpg" alt="Description de l'image"&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;div&gt;</strong> : Division de contenu (utilisé pour regrouper des éléments et appliquer des styles ou des scripts). Il est souvent utilisé avec des classes ou des identifiants pour appliquer des styles CSS ou des scripts JavaScript. Exemple :
                            <pre>
                            <code>
&lt;div class="container"&gt;
&lt;h2&gt;Titre de la section&lt;/h2&gt;
&lt;p&gt;Contenu de la section.&lt;/p&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;form&gt;</strong> : Formulaire (utilisé pour collecter des données auprès des utilisateurs, contient des éléments comme des champs de texte, des boutons, etc.). Les formulaires sont utilisés pour envoyer des données à un serveur pour traitement. Exemple :
                            <pre>
                            <code>
&lt;form action="/submit" method="post"&gt;
&lt;label for="name"&gt;Nom:&lt;/label&gt;
&lt;input type="text" id="name" name="name"&gt;
&lt;input type="submit" value="Envoyer"&gt;
&lt;/form&gt;
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section CSS -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#cssSection" aria-expanded="false" aria-controls="cssSection">
                    CSS (Cascading Style Sheets)
                </button>
            </h2>
            <div id="cssSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>color</strong> : Couleur du texte (définit la couleur du texte d'un élément, peut être spécifiée en nom de couleur, code hexadécimal, RGB, etc.). Utilisé pour styliser le texte et améliorer la lisibilité ou l'esthétique. Exemple :
                            <pre>
                            <code>
p {
    color: red; /* Utilise le nom de couleur */
    color: #ff0000; /* Utilise le code hexadécimal */
    color: rgb(255, 0, 0); /* Utilise le code RGB */
}
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>background-color</strong> : Couleur de fond (définit la couleur de fond d'un élément, peut être spécifiée en nom de couleur, code hexadécimal, RGB, etc.). Utilisé pour mettre en évidence des sections ou des éléments spécifiques. Exemple :
                            <pre>
                            <code>
div {
    background-color: blue; /* Utilise le nom de couleur */
    background-color: #0000ff; /* Utilise le code hexadécimal */
    background-color: rgb(0, 0, 255); /* Utilise le code RGB */
}
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>padding</strong> : Espacement interne (espace entre le contenu d'un élément et ses bordures, peut être spécifié en pixels, pourcentages, etc.). Utilisé pour créer de l'espace autour du contenu à l'intérieur d'un élément. Exemple :
                            <pre>
                            <code>
div {
    padding: 10px; /* Espacement de 10 pixels */
    padding: 5%; /* Espacement de 5% de la largeur de l'élément */
}
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>margin</strong> : Espacement externe (espace autour d'un élément, séparant l'élément de ses voisins, peut être spécifié en pixels, pourcentages, etc.). Utilisé pour créer de l'espace autour des éléments. Exemple :
                            <pre>
                            <code>
div {
    margin: 20px; /* Espacement de 20 pixels */
    margin: 10%; /* Espacement de 10% de la largeur de l'élément */
}
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>border</strong> : Bordure d'un élément (définit la bordure autour d'un élément, peut inclure la largeur, le style et la couleur). Utilisé pour encadrer des éléments et les distinguer visuellement. Exemple :
                            <pre>
                            <code>
div {
    border: 2px solid black; /* Bordure de 2 pixels, style solide, couleur noire */
    border: 1px dashed red; /* Bordure de 1 pixel, style en pointillés, couleur rouge */
}
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>display</strong> : Contrôle de l'affichage (définit comment un élément est affiché, valeurs courantes : <code>block</code> pour un bloc, <code>inline</code> pour un élément en ligne, <code>flex</code> pour un conteneur flexible). Utilisé pour gérer la disposition des éléments. Exemple :
                            <pre>
                            <code>
div {
    display: block; /* Affiche l'élément comme un bloc */
    display: inline; /* Affiche l'élément en ligne */
    display: flex; /* Utilise le modèle de boîte flexible */
}
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>position</strong> : Positionnement d'un élément (définit comment un élément est positionné dans le document, valeurs courantes : <code>static</code> pour le positionnement normal, <code>absolute</code> pour un positionnement absolu, <code>relative</code> pour un positionnement relatif à sa position normale). Utilisé pour contrôler la position des éléments sur la page. Exemple :
                            <pre>
                            <code>
div {
    position: static; /* Positionnement normal */
    position: absolute; /* Positionnement absolu */
    position: relative; /* Positionnement relatif */
}
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>media queries</strong> : Adaptation des styles selon la taille de l'écran (permet d'appliquer des styles CSS spécifiques en fonction des caractéristiques du dispositif, comme la largeur de l'écran, la résolution, etc.). Utilisé pour créer des designs réactifs. Exemple :
                            <pre>
                            <code>
&#64;media (max-width: 600px) {
body {
    background-color: lightblue;
}
                              }
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section JavaScript -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#jsSection" aria-expanded="false" aria-controls="jsSection">
                    JavaScript (JS)
                </button>
            </h2>
            <div id="jsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>let</strong>, <strong>const</strong>, <strong>var</strong> : Déclaration de variables. Utilisé pour déclarer des variables en JavaScript avec des portées différentes. Exemple :
                            <pre>
                            <code>
let x = 10; // Portée de bloc
const y = 20; // Portée de bloc, valeur constante
var z = 30; // Portée de fonction
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>function</strong> : Définition de fonction. Utilisé pour déclarer des fonctions en JavaScript. Exemple :
                            <pre>
                            <code>
function greet(name) {
    return `Hello, ${name}!`;
}
console.log(greet("Alice")); // Affiche "Hello, Alice!"
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>DOM</strong> : Document Object Model, pour manipuler le HTML. Utilisé pour accéder et manipuler les éléments HTML via JavaScript. Exemple :
                            <pre>
                            <code>
document.getElementById("myElement").innerHTML = "Nouveau contenu";
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>addEventListener</strong> : Gestion des événements. Utilisé pour attacher des gestionnaires d'événements aux éléments HTML. Exemple :
                            <pre>
                            <code>
document.getElementById("myButton").addEventListener("click", function() {
    alert("Bouton cliqué!");
});
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>fetch</strong> : Requête HTTP pour récupérer des données. Utilisé pour effectuer des requêtes HTTP et récupérer des données de manière asynchrone. Exemple :
                            <pre>
                            <code>
fetch("https://api.example.com/data")
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error("Erreur:", error));
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>localStorage</strong>, <strong>sessionStorage</strong> : Stockage local dans le navigateur. Utilisé pour stocker des données côté client. Exemple :
                            <pre>
                            <code>
localStorage.setItem("key", "value");
let value = localStorage.getItem("key");
sessionStorage.setItem("sessionKey", "sessionValue");
let sessionValue = sessionStorage.getItem("sessionKey");
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>JSON</strong> : Format de données JavaScript Object Notation. Utilisé pour échanger des données entre un client et un serveur. Exemple :
                            <pre>
                            <code>
let jsonString = '{"name": "Alice", "age": 25}';
let jsonObject = JSON.parse(jsonString);
console.log(jsonObject.name); // Affiche "Alice"
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>promise</strong>, <strong>async/await</strong> : Gestion asynchrone. Utilisé pour gérer des opérations asynchrones en JavaScript. Exemple :
                            <pre>
                            <code>
function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => resolve("Données récupérées"), 2000);
    });
}

async function getData() {
    try {
        let data = await fetchData();
        console.log(data); // Affiche "Données récupérées" après 2 secondes
    } catch (error) {
        console.error("Erreur:", error);
    }
}

getData();
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Frameworks JavaScript -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#frameworksSection" aria-expanded="false" aria-controls="frameworksSection">
                    Frameworks et Bibliothèques JavaScript
                </button>
            </h2>
            <div id="frameworksSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>jQuery</strong> : Simplifie la manipulation du DOM et les requêtes AJAX. Utilisé pour écrire moins de code JavaScript pour des tâches courantes. Exemple :
                            <pre>
                            <code>
$(document).ready(function() {
    $("#myButton").click(function() {
        alert("Bouton cliqué!");
    });
});
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>React.js</strong> : Bibliothèque pour créer des interfaces utilisateur. Utilisé pour construire des composants réutilisables et gérer l'état de l'application. Exemple :
                            <pre>
                            <code>
import React, { useState } from 'react';

function App() {
    const [count, setCount] = useState(0);

    return (
                            <div>
                            <p>Vous avez cliqué {count} fois</p>
                            <button onClick={() => setCount(count + 1)}>
                Cliquez ici
            </button>
        </div>
    );
}

export default App;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Vue.js</strong> : Framework pour créer des interfaces utilisateur réactives. Utilisé pour construire des applications web interactives. Exemple :
                            <pre>
                            <code>
                            <template>
                            <div id="app">
                            <p>{{ message }}</p>
                            <button @click="reverseMessage">Inverser le message</button>
                          </div>
                        </template>

                            <script>
                                export default {
                                    data() {
                                        return {
                                            message: 'Bonjour Vue!'
                                        }
                                    },
                                    methods: {
                                        reverseMessage() {
                                            this.message = this.message.split('').reverse().join('')
                                        }
                                    }
                                }
</script>
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Angular</strong> : Framework complet pour les applications web complexes. Utilisé pour construire des applications web robustes et maintenables. Exemple :
                            <pre>
                            <code>
import { Component } from '&#64;angular/core';

&#64;Component({
    selector: 'app-root',
    template: `
    &lt:h1&gt;{{ title }}&lt;/&lt:h1&gt;
                            <button (click)="changeTitle()">Changer le titre</button>
    `
})
export class AppComponent {
    title = 'Bienvenue sur Angular';

    changeTitle() {
    this.title = 'Titre changé!';
    }
}
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Node.js</strong> : Exécute du JavaScript côté serveur. Utilisé pour construire des applications serveur rapides et évolutives. Exemple :
                            <pre>
                            <code>
const http = require('http');

const server = http.createServer((req, res) => {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'text/plain');
    res.end('Hello World\n');
});

server.listen(3000, '127.0.0.1', () => {
    console.log('Serveur en cours d\'exécution sur http://127.0.0.1:3000/');
});
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Express.js</strong> : Framework minimal pour des applications Node.js. Utilisé pour construire des applications web et des API. Exemple :
                            <pre>
                            <code>
const express = require('express');
const app = express();

app.get('/', (req, res) => {
res.send('Hello World!');
});

app.listen(3000, () => {
console.log('Serveur en cours d\'exécution sur http://localhost:3000/');
});
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Base de Données -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#dbSection" aria-expanded="false" aria-controls="dbSection">
                    Bases de Données (Back-end)
                </button>
            </h2>
            <div id="dbSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>SQL</strong> : Langage pour interagir avec des bases de données relationnelles. Utilisé pour effectuer des requêtes sur des bases de données structurées. Exemple :
                            <pre>
                            <code>
SELECT * FROM utilisateurs WHERE age > 30;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>NoSQL</strong> : Bases de données non relationnelles (par ex. MongoDB). Utilisé pour stocker des données non structurées ou semi-structurées. Exemple :
                            <pre>
                            <code>
db.utilisateurs.insert({ nom: "Alice", age: 25 });
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>CRUD</strong> : Create, Read, Update, Delete (opérations basiques). Utilisé pour les opérations de base sur les données. Exemple :
                            <pre>
                            <code>
// Create
INSERT INTO utilisateurs (nom, age) VALUES ('Alice', 25);

// Read
SELECT * FROM utilisateurs;

// Update
UPDATE utilisateurs SET age = 26 WHERE nom = 'Alice';

// Delete
DELETE FROM utilisateurs WHERE nom = 'Alice';
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ORM</strong> : Object-Relational Mapping pour interagir avec des bases via des objets. Utilisé pour simplifier les interactions avec les bases de données en utilisant des objets. Exemple :
                            <pre>
                            <code>
class Utilisateur {
    constructor(nom, age) {
        this.nom = nom;
        this.age = age;
    }
}

let utilisateur = new Utilisateur('Alice', 25);
utilisateur.save(); // Sauvegarde l'utilisateur dans la base de données
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Hébergement -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#hostingSection" aria-expanded="false" aria-controls="hostingSection">
                    Hébergement et Déploiement
                </button>
            </h2>
            <div id="hostingSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>FTP</strong> : Protocole de transfert de fichiers. Utilisé pour transférer des fichiers entre un client et un serveur sur un réseau. FTP est souvent utilisé pour télécharger des fichiers sur un serveur web ou pour récupérer des fichiers depuis un serveur. Exemple :
                            <pre>
                            <code>
ftp&gt; open ftp.example.com
ftp&gt; login
ftp&gt; put localfile.txt remotefile.txt
ftp&gt; get remotefile.txt localfile.txt
ftp&gt; bye
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>CDN</strong> : Content Delivery Network. Réseau de serveurs distribués géographiquement qui travaillent ensemble pour fournir rapidement du contenu Internet aux utilisateurs. Les CDNs sont utilisés pour améliorer les temps de chargement des sites web et réduire la latence. Exemple :
                            <pre>
                            <code>
&lt;script src="https://cdn.example.com/library.js"&gt;&lt;/script&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>SSL/TLS</strong> : Protocoles de sécurisation des communications sur le web. SSL (Secure Sockets Layer) et TLS (Transport Layer Security) chiffrent les données échangées entre un client et un serveur, garantissant la confidentialité et l'intégrité des données. Exemple :
                            <pre>
                            <code>
https://www.example.com
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Hosting Providers</strong> : Fournisseurs de services d'hébergement. Entreprises qui offrent des services pour héberger des sites web, des applications et des bases de données. Exemples : AWS (Amazon Web Services), Azure (Microsoft), Heroku, Netlify. Exemple :
                            <pre>
                            <code>
# Déploiement sur Heroku
$ git init
$ heroku create
$ git add .
$ git commit -m "Initial commit"
$ git push heroku master
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire HTML</h1>

    <div class="accordion">
        <!-- Section Éléments de Structure de Base -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#htmlBasicsSection" 
                aria-expanded="false" aria-controls="htmlBasicsSection">
                    Éléments de Structure de Base
                </button>
            </h2>
            <div id="htmlBasicsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>&lt;html&gt;</strong> : Élément racine qui encapsule tout le contenu HTML de la page. Il doit contenir deux éléments principaux : <code>&lt;head&gt;</code> et <code>&lt;body&gt;</code>. L'élément <code>&lt;html&gt;</code> définit le début et la fin d'un document HTML. Par exemple :
                            <pre>
                            <code>
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Titre de la page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;Contenu de la page&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;head&gt;</strong> : Contient les métadonnées, les liens vers les fichiers CSS, les balises <code>&lt;meta&gt;</code> et le titre de la page <code>&lt;title&gt;</code>. Les métadonnées incluent des informations comme le jeu de caractères, les auteurs du document, et les instructions pour les moteurs de recherche. Les fichiers CSS liés dans le <code>&lt;head&gt;</code> définissent le style de la page. Par exemple :
                            <pre>
                            <code>
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;title&gt;Titre de la page&lt;/title&gt;
&lt;link rel="stylesheet" href="styles.css"&gt;
&lt;/head&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;body&gt;</strong> : Contient tout le contenu visible d'une page web (texte, images, vidéos, etc.). C'est dans cet élément que vous placez les balises HTML qui définissent la structure et le contenu de la page, comme les paragraphes, les titres, les listes, les images, et les liens. Par exemple :
                            <pre>
                            <code>
&lt;body&gt;
&lt;h1&gt;Bienvenue&lt;/h1&gt;
&lt;p&gt;Ceci est un paragraphe de texte.&lt;/p&gt;
&lt;img src="image.jpg" alt="Description de l'image"&gt;
&lt;/body&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;h1&gt; à &lt;h6&gt;</strong> : Balises de titres, où <code>&lt;h1&gt;</code> est le plus important et <code>&lt;h6&gt;</code> le moins. Les titres sont utilisés pour structurer le contenu et améliorer la lisibilité. Ils jouent également un rôle important dans le référencement (SEO) en aidant les moteurs de recherche à comprendre la hiérarchie et le contenu de la page. Par exemple :
                            <pre>
                            <code>
&lt;h1&gt;Titre Principal&lt;/h1&gt;
&lt;h2&gt;Sous-titre&lt;/h2&gt;
&lt;h3&gt;Sous-sous-titre&lt;/h3&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;p&gt;</strong> : Élément pour créer des paragraphes de texte. Chaque paragraphe est automatiquement séparé par un espace vertical, ce qui améliore la lisibilité du texte. Les paragraphes sont utilisés pour structurer le contenu textuel en blocs logiques. Par exemple :
                            <pre><code>&lt;p&gt;Ceci est un paragraphe de texte.&lt;/p&gt;</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;div&gt;</strong> : Élément conteneur générique utilisé pour regrouper d'autres éléments en blocs. Il est souvent utilisé avec des classes ou des identifiants pour appliquer des styles CSS ou des scripts JavaScript. Les <code>&lt;div&gt;</code> sont essentiels pour la mise en page et l'organisation du contenu. Par exemple :
                            <pre>
                            <code>
&lt;div class="container"&gt;
&lt;h2&gt;Titre de la section&lt;/h2&gt;
&lt;p&gt;Contenu de la section.&lt;/p&gt;
&lt;/div&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;span&gt;</strong> : Élément conteneur générique utilisé pour regrouper des parties de texte ou des éléments en ligne. Contrairement à <code>&lt;div&gt;</code>, <code>&lt;span&gt;</code> n'introduit pas de rupture de ligne. Il est souvent utilisé pour appliquer des styles ou des scripts à une partie spécifique du texte sans affecter la mise en page globale. Par exemple :
                            <pre><code>&lt;p&gt;Texte avec un &lt;span style="color: red;"&gt;mot en rouge&lt;/span&gt;.&lt;/p&gt;</code></pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Liens et Images -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#linksImagesSection" aria-expanded="false" aria-controls="linksImagesSection">
                    Liens et Images
                </button>
            </h2>
            <div id="linksImagesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>&lt;a&gt;</strong> : Balise utilisée pour créer des liens hypertextes. L'attribut <code>href</code> définit l'URL de destination. Vous pouvez également utiliser des attributs comme <code>target</code> pour ouvrir le lien dans un nouvel onglet (<code>_blank</code>) et <code>rel</code> pour définir la relation entre le document actuel et le document lié (par exemple, <code>noopener</code> pour des raisons de sécurité). Par exemple :
                            <pre><code>&lt;a href="https://example.com" target="_blank" rel="noopener"&gt;Visitez Example&lt;/a&gt;</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;img&gt;</strong> : Élément pour insérer des images. L'attribut <code>src</code> indique la source de l'image, et <code>alt</code> fournit une description alternative pour les lecteurs d'écran et les cas où l'image ne peut pas être affichée. Vous pouvez également utiliser des attributs comme <code>width</code> et <code>height</code> pour définir les dimensions de l'image, et <code>loading="lazy"</code> pour différer le chargement des images hors écran. Par exemple :
                            <pre><code>&lt;img src="image.jpg" alt="Description de l'image" width="600" height="400" loading="lazy" /&gt;</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;figure&gt;</strong> : Élément utilisé pour regrouper des éléments comme une image avec une légende. Il est souvent utilisé pour améliorer la sémantique et l'accessibilité des contenus visuels. L'élément <code>&lt;figure&gt;</code> peut contenir des images, des graphiques, des diagrammes ou tout autre contenu visuel, ainsi que leur légende associée. Par exemple :
                            <pre>
                            <code>
&lt;figure&gt;
&lt;img src="diagram.png" alt="Diagramme explicatif" /&gt;
&lt;figcaption&gt;Diagramme montrant les étapes du processus.&lt;/figcaption&gt;
&lt;/figure&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;figcaption&gt;</strong> : Légende associée à un élément <code>&lt;figure&gt;</code>. Il fournit une description ou une explication du contenu visuel contenu dans le <code>&lt;figure&gt;</code>. La balise <code>&lt;figcaption&gt;</code> doit être placée directement après l'élément visuel ou à la fin de l'élément <code>&lt;figure&gt;</code>. Par exemple :
                            <pre>
                            <code>
&lt;figure&gt;
&lt;img src="photo.jpg" alt="Photo de paysage" /&gt;
&lt;figcaption&gt;Une belle vue de la montagne au lever du soleil.&lt;/figcaption&gt;
&lt;/figure&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;nav&gt;</strong> : Élément sémantique pour définir des sections de navigation, contenant des liens vers d'autres parties du site ou des pages externes. Il améliore l'accessibilité en permettant aux lecteurs d'écran et aux moteurs de recherche de comprendre la structure de navigation du site. L'élément <code>&lt;nav&gt;</code> est généralement utilisé pour les menus de navigation principaux, les barres latérales de navigation, et les liens de pied de page. Par exemple :
                            <pre>
                            <code>
&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/home"&gt;Accueil&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/about"&gt;À propos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/contact"&gt;Contact&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;                    
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Listes et Tableaux -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#listsTablesSection" aria-expanded="false" aria-controls="listsTablesSection">
                    Listes et Tableaux
                </button>
            </h2>
            <div id="listsTablesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>&lt;ul&gt;</strong> : Liste à puces non ordonnée. Les éléments de liste sont créés avec <code>&lt;li&gt;</code>. Utilisée pour regrouper des éléments sans ordre particulier. Par exemple :
                            <pre>
                            <code>
&lt;ul&gt;
&lt;li&gt;Élément 1&lt;/li&gt;
&lt;li&gt;Élément 2&lt;/li&gt;
&lt;li&gt;Élément 3&lt;/li&gt;
&lt;/ul&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;ol&gt;</strong> : Liste ordonnée avec des numéros ou lettres pour chaque élément. Utilisée pour regrouper des éléments avec un ordre spécifique. Par exemple :
                            <pre>
                            <code>
&lt;ol&gt;
&lt;li&gt;Premier élément&lt;/li&gt;
&lt;li&gt;Deuxième élément&lt;/li&gt;
&lt;li&gt;Troisième élément&lt;/li&gt;
&lt;/ol&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;li&gt;</strong> : Élément de liste utilisé à l'intérieur de <code>&lt;ul&gt;</code> ou <code>&lt;ol&gt;</code>. Représente un élément individuel dans une liste. Par exemple :
                            <pre>
                            <code>
&lt;ul&gt;
&lt;li&gt;Élément de liste non ordonnée&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Élément de liste ordonnée&lt;/li&gt;
&lt;/ol&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;table&gt;</strong> : Élément pour créer des tableaux. Utilisé avec <code>&lt;tr&gt;</code> (ligne), <code>&lt;td&gt;</code> (cellule), et <code>&lt;th&gt;</code> (en-tête de tableau). Permet de structurer des données en lignes et colonnes. Par exemple :
                            <pre>
                            <code>
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;En-tête 1&lt;/th&gt;
&lt;th&gt;En-tête 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Donnée 1&lt;/td&gt;
&lt;td&gt;Donnée 2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;thead&gt;</strong> : Élément utilisé pour regrouper les en-têtes de colonnes dans un tableau. Placé généralement au début du tableau pour définir les titres des colonnes. Par exemple :
                            <pre>
                            <code>
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Titre 1&lt;/th&gt;
&lt;th&gt;Titre 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;tbody&gt;</strong> : Section utilisée pour regrouper le contenu du tableau à l'intérieur de <code>&lt;table&gt;</code>. Contient les lignes de données du tableau, séparées des en-têtes. Par exemple :
                            <pre>
                            <code>
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Donnée 1&lt;/td&gt;
&lt;td&gt;Donnée 2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Formulaires -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#formsSection" aria-expanded="false" aria-controls="formsSection">
                    Formulaires
                </button>
            </h2>
            <div id="formsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>&lt;form&gt;</strong> : Élément utilisé pour regrouper des champs d'entrée utilisateur et envoyer des données à un serveur. Il peut contenir divers éléments de formulaire comme des champs de texte, des boutons, des cases à cocher, etc. L'attribut <code>action</code> spécifie l'URL où les données du formulaire doivent être envoyées, et l'attribut <code>method</code> spécifie la méthode HTTP (GET ou POST) à utiliser pour l'envoi des données. Par exemple :
                            <pre>
                            <code>
&lt;form action="/submit" method="post"&gt;
&lt;input type="text" name="username" placeholder="Nom d'utilisateur" /&gt;
&lt;button type="submit"&gt;Envoyer&lt;/button&gt;
&lt;/form&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;input&gt;</strong> : Élément d'entrée de données, utilisé pour créer différents types de champs comme des zones de texte, des cases à cocher, ou des boutons radio. L'attribut <code>type</code> spécifie le type de champ (par exemple, <code>text</code> pour une zone de texte, <code>checkbox</code> pour une case à cocher, <code>radio</code> pour un bouton radio, etc.). D'autres attributs comme <code>name</code>, <code>value</code>, et <code>placeholder</code> peuvent être utilisés pour définir des propriétés supplémentaires. Par exemple :
                            <pre><code>&lt;input type="text" name="email" placeholder="Adresse e-mail" /&gt;</code></pre>
                            Un autre exemple pour une case à cocher :
                            <pre><code>&lt;input type="checkbox" name="subscribe" value="yes" /&gt; S'abonner à la newsletter</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;label&gt;</strong> : Étiquette pour un élément de formulaire, souvent utilisée avec l'attribut <code>for</code> qui fait référence à l'identifiant d'un champ de formulaire. Cela améliore l'accessibilité en associant visuellement et fonctionnellement l'étiquette au champ de formulaire correspondant. Par exemple :
                            <pre>
                            <code>
&lt;label for="username"&gt;Nom d'utilisateur&lt;/label&gt;
&lt;input type="text" id="username" name="username" /&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;select&gt;</strong> : Élément pour créer un menu déroulant de choix multiples. Utilisé avec des balises <code>&lt;option&gt;</code> pour définir les options disponibles. L'attribut <code>name</code> est utilisé pour identifier le menu déroulant lors de l'envoi du formulaire, et l'attribut <code>multiple</code> peut être ajouté pour permettre la sélection de plusieurs options. Par exemple :
                            <pre>
                            <code>
&lt;select name="country"&gt;
&lt;option value="fr"&gt;France&lt;/option&gt;
&lt;option value="us"&gt;États-Unis&lt;/option&gt;
&lt;/select&gt;
                                </code>
                            </pre>
                            Un autre exemple pour une sélection multiple :
                            <pre>
                            <code>
&lt;select name="fruits" multiple&gt;
&lt;option value="apple"&gt;Pomme&lt;/option&gt;
&lt;option value="banana"&gt;Banane&lt;/option&gt;
&lt;/select&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;textarea&gt;</strong> : Zone de texte multilignes pour les grandes entrées de texte. Contrairement à <code>&lt;input&gt;</code> avec <code>type="text"</code>, <code>&lt;textarea&gt;</code> permet aux utilisateurs de saisir du texte sur plusieurs lignes. Les attributs <code>rows</code> et <code>cols</code> peuvent être utilisés pour définir la taille de la zone de texte. Par exemple :
                            <pre><code>&lt;textarea name="message" rows="4" cols="50"&gt;Votre message ici...&lt;/textarea&gt;</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;button&gt;</strong> : Élément pour créer des boutons interactifs. L'attribut <code>type</code> peut être utilisé pour spécifier le type de bouton (par exemple, <code>submit</code> pour envoyer un formulaire, <code>reset</code> pour réinitialiser les champs du formulaire, ou <code>button</code> pour un bouton sans comportement par défaut). Le contenu entre les balises <code>&lt;button&gt;</code> et <code>&lt;/button&gt;</code> est affiché comme étiquette du bouton. Par exemple :
                            <pre><code>&lt;button type="submit"&gt;Envoyer&lt;/button&gt;</code></pre>
                            Un autre exemple pour un bouton de réinitialisation :
                            <pre><code>&lt;button type="reset"&gt;Réinitialiser&lt;/button&gt;</code></pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Éléments Sémantiques -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#semanticSection" aria-expanded="false" aria-controls="semanticSection">
                    Éléments Sémantiques
                </button>
            </h2>
            <div id="semanticSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>&lt;header&gt;</strong> : Section d'en-tête pour les informations introductives ou les liens de navigation. Généralement utilisée pour regrouper des éléments comme le logo, le titre du site, et les menus de navigation. Elle est placée en haut de la page ou d'une section. Par exemple :
                            <pre>
                            <code>
&lt;header&gt;
&lt;h1&gt;Titre du Site&lt;/h1&gt;
&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#"&gt;Accueil&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#"&gt;À propos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;
&lt;/header&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;footer&gt;</strong> : Section de pied de page contenant des informations de bas de page, des crédits ou des liens supplémentaires. Souvent utilisée pour afficher des informations de contact, des mentions légales, des liens vers des politiques de confidentialité, et des crédits. Elle est placée en bas de la page ou d'une section. Par exemple :
                            <pre>
                            <code>
&lt;footer&gt;
&lt;p&gt;© 2023 Mon Site Web&lt;/p&gt;
&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#"&gt;Mentions légales&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#"&gt;Politique de confidentialité&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;
&lt;/footer&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;article&gt;</strong> : Contenu autonome qui peut être distribué indépendamment, comme un article de blog ou une entrée de journal. Utilisé pour encapsuler un contenu qui a un sens complet en soi et qui peut être réutilisé ou syndiqué. Par exemple :
                            <pre>
                            <code>
&lt;article&gt;
&lt;h2&gt;Titre de l'Article&lt;/h2&gt;
&lt;p&gt;Contenu de l'article...&lt;/p&gt;
&lt;/article&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;section&gt;</strong> : Section thématique d'une page qui regroupe des éléments connexes. Utilisée pour diviser le contenu en sections logiques, chaque section ayant généralement un titre. Elle aide à structurer le document de manière sémantique. Par exemple :
                            <pre>
                            <code>
&lt;section&gt;
&lt;h2&gt;Titre de la Section&lt;/h2&gt;
&lt;p&gt;Contenu de la section...&lt;/p&gt;
&lt;/section&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;aside&gt;</strong> : Contenu secondaire ou complémentaire, comme des barres latérales ou des citations. Utilisé pour des informations qui sont tangentielles au contenu principal, comme des publicités, des liens connexes, ou des citations. Placé souvent à côté du contenu principal. Par exemple :
                            <pre>
                            <code>
&lt;aside&gt;
&lt;h2&gt;Liens Connexes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#"&gt;Lien 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#"&gt;Lien 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/aside&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>&lt;main&gt;</strong> : Section principale d'un document qui contient le contenu dominant. Utilisée pour encapsuler le contenu principal de la page, distinct des en-têtes, pieds de page, et barres latérales. Il ne doit y avoir qu'un seul élément <code>&lt;main&gt;</code> par document. Par exemple :
                            <pre>
                            <code>
&lt;main&gt;
&lt;h1&gt;Bienvenue sur Mon Site&lt;/h1&gt;
&lt;p&gt;Contenu principal de la page...&lt;/p&gt;
&lt;/main&gt;
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire CSS</h1>

    <div class="accordion">
        <!-- Section Sélecteurs -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#selectorsSection" aria-expanded="false" aria-controls="selectorsSection">
                    Sélecteurs CSS
                </button>
            </h2>
            <div id="selectorsSection" class="accordion-collapse collapse ">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Sélecteur universel (*)</strong> : Sélecteur qui cible tous les éléments d'une page. Utilisé pour appliquer des styles généraux à tous les éléments sans exception. Par exemple :
                            <pre>
                            <code>
* {
    margin: 0;
    padding: 0;
}
                                </code>
                            </pre>
                            Cela réinitialise les marges et les espacements internes de tous les éléments.
                        </li>
                        <li class="list-group-item">
                            <strong>Sélecteur de type (p, h1, div, etc.)</strong> : Cible tous les éléments d'un certain type. Par exemple :
                            <pre>
                            <code>
p {
    color: blue;
}
                                </code>
                            </pre>
                            Cela cible tous les paragraphes et définit leur couleur en bleu. Un autre exemple :
                            <pre>
                            <code>
h1 {
    font-size: 2em;
}
                                </code>
                            </pre>
                            Cela cible tous les titres de niveau 1 et définit leur taille de police à 2em.
                        </li>
                        <li class="list-group-item">
                            <strong>Sélecteur de classe (.classname)</strong> : Cible tous les éléments ayant une classe spécifique. Par exemple :
                            <pre>
                            <code>
.menu {
    background-color: #f0f0f0;
}
                                </code>
                            </pre>
                            Cela cible tous les éléments avec la classe "menu" et définit leur couleur de fond à #f0f0f0.
                        </li>
                        <li class="list-group-item">
                            <strong>Sélecteur d'ID (#idname)</strong> : Cible un élément ayant un identifiant unique. Par exemple :
                            <pre>
                            <code>
#header {
    text-align: center;
}
                                </code>
                            </pre>
                            Cela cible l'élément avec l'ID "header" et centre son texte.
                        </li>
                        <li class="list-group-item">
                            <strong>Sélecteur descendant (parent child)</strong> : Cible les éléments enfants d'un élément parent spécifique. Par exemple :
                            <pre>
                            <code>
div p {
    margin-bottom: 10px;
}
                                </code>
                            </pre>
                            Cela cible tous les paragraphes à l'intérieur des div et définit une marge inférieure de 10 pixels.
                        </li>
                        <li class="list-group-item">
                            <strong>Sélecteur d'attribut ([attribute=value])</strong> : Cible les éléments ayant un attribut spécifique. Par exemple :
                            <pre>
                            <code>
[type="text"] {
    border: 1px solid #ccc;
}
                                </code>
                            </pre>
                            Cela cible tous les champs de texte et définit une bordure de 1 pixel solide et de couleur #ccc.
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Propriétés de Texte -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#textPropertiesSection" aria-expanded="false" aria-controls="textPropertiesSection">
                    Propriétés de Texte
                </button>
            </h2>
            <div id="textPropertiesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>color</strong> : Définit la couleur du texte. Peut être spécifiée en utilisant des noms de couleur (ex: <code>red</code>), des valeurs hexadécimales (ex: <code>#ff0000</code>), des valeurs RGB (ex: <code>rgb(255, 0, 0)</code>), ou des valeurs HSL (ex: <code>hsl(0, 100%, 50%)</code>). Par exemple :
                            <pre><code>color: blue;</code></pre>
                            Cela définit la couleur du texte en bleu.
                        </li>
                        <li class="list-group-item">
                            <strong>font-size</strong> : Définit la taille de la police. Peut être spécifiée en pixels (ex: <code>16px</code>), en em (ex: <code>1em</code>), en rem (ex: <code>1rem</code>), en pourcentages (ex: <code>100%</code>), ou en points (ex: <code>12pt</code>). Par exemple :
                            <pre><code>font-size: 20px;</code></pre>
                            Cela définit la taille de la police à 20 pixels.
                        </li>
                        <li class="list-group-item">
                            <strong>font-weight</strong> : Définit la graisse de la police. Les valeurs courantes incluent <code>normal</code>, <code>bold</code>, <code>bolder</code>, <code>lighter</code>, ou des valeurs numériques allant de 100 à 900. Par exemple :
                            <pre><code>font-weight: bold;</code></pre>
                            Cela rend le texte en gras.
                        </li>
                        <li class="list-group-item">
                            <strong>text-align</strong> : Définit l'alignement du texte. Les valeurs courantes incluent <code>left</code> (gauche), <code>center</code> (centré), <code>right</code> (droite), et <code>justify</code> (justifié). Par exemple :
                            <pre><code>text-align: center;</code></pre>
                            Cela centre le texte horizontalement.
                        </li>
                        <li class="list-group-item">
                            <strong>line-height</strong> : Définit l'espacement entre les lignes de texte. Peut être spécifiée en unités relatives (ex: <code>1.5</code>), en pixels (ex: <code>24px</code>), ou en pourcentages (ex: <code>150%</code>). Par exemple :
                            <pre><code>line-height: 1.5;</code></pre>
                            Cela définit un espacement de 1.5 fois la taille de la police entre les lignes.
                        </li>
                        <li class="list-group-item">
                            <strong>text-transform</strong> : Contrôle la capitalisation du texte. Les valeurs courantes incluent <code>uppercase</code> (majuscule), <code>lowercase</code> (minuscule), <code>capitalize</code> (première lettre en majuscule), et <code>none</code> (aucune transformation). Par exemple :
                            <pre><code>text-transform: uppercase;</code></pre>
                            Cela transforme tout le texte en majuscules.
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Modèle de Boîte -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#boxModelSection" aria-expanded="false" aria-controls="boxModelSection">
                    Modèle de Boîte (Box Model)
                </button>
            </h2>
            <div id="boxModelSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>width / height</strong> : Définit la largeur et la hauteur d'un élément. La valeur peut être spécifiée en unités absolues (comme pixels, points) ou relatives (comme pourcentages, em, rem). Par exemple :
                            <pre><code>width: 100px;</code></pre>
                            Cela définit une largeur de 100 pixels. Un autre exemple :
                            <pre><code>height: 50%;</code></pre>
                            Cela définit une hauteur de 50% de la hauteur de l'élément parent.
                        </li>
                        <li class="list-group-item">
                            <strong>padding</strong> : Définit l'espace intérieur entre le contenu et la bordure d'un élément. Les valeurs peuvent être spécifiées pour chaque côté individuellement (haut, droite, bas, gauche) ou de manière abrégée. Par exemple :
                            <pre><code>padding: 10px 20px;</code></pre>
                            Cela définit un espacement de 10 pixels en haut et en bas, et 20 pixels à droite et à gauche. Un autre exemple :
                            <pre>
                            <code>
padding-top: 5px;
padding-right: 15px;
padding-bottom: 5px;
padding-left: 15px;
                                </code>
                            </pre>
                            Cela définit des espacements spécifiques pour chaque côté.
                        </li>
                        <li class="list-group-item">
                            <strong>margin</strong> : Définit l'espace extérieur autour d'un élément. Comme pour le padding, les valeurs peuvent être spécifiées pour chaque côté individuellement ou de manière abrégée. Par exemple :
                            <pre><code>margin: 15px 30px;</code></pre>
                            Cela définit un espacement de 15 pixels en haut et en bas, et 30 pixels à droite et à gauche. Un autre exemple :
                            <pre>
                            <code>
margin-top: 10px;
margin-right: 20px;
margin-bottom: 10px;
margin-left: 20px;
                                </code>
                            </pre>
                            Cela définit des espacements spécifiques pour chaque côté.
                        </li>
                        <li class="list-group-item">
                            <strong>border</strong> : Définit la bordure d'un élément, incluant son épaisseur, son style et sa couleur. Par exemple :
                            <pre><code>border: 1px solid black;</code></pre>
                            Cela définit une bordure noire, pleine et d'une épaisseur de 1 pixel. Un autre exemple :
                            <pre>
                            <code>
border-width: 2px;
border-style: dashed;
border-color: red;
                                </code>
                            </pre>
                            Cela définit une bordure rouge, en pointillés et d'une épaisseur de 2 pixels.
                        </li>
                        <li class="list-group-item">
                            <strong>box-sizing</strong> : Définit la manière dont la largeur et la hauteur d'un élément sont calculées. Par exemple :
                            <pre><code>box-sizing: border-box;</code></pre>
                            Cela assure que la largeur et la hauteur incluent le padding et la bordure. Un autre exemple :
                            <pre><code>box-sizing: content-box;</code></pre>
                            Cela inclut uniquement le contenu dans la largeur et la hauteur.
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Mise en Page et Positionnement -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#layoutPositioningSection" aria-expanded="false" aria-controls="layoutPositioningSection">
                    Mise en Page et Positionnement
                </button>
            </h2>
            <div id="layoutPositioningSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>display</strong> : Contrôle la manière dont un élément est affiché. Par exemple :
                            <pre><code>display: block;</code></pre>
                            Cela fait que l'élément occupe toute la largeur disponible. Autres exemples :
                            <pre><code>display: inline;</code></pre>
                            Cela fait que l'élément occupe seulement l'espace nécessaire.
                            <pre><code>display: flex;</code></pre>
                            Cela permet une mise en page flexible.
                            <pre><code>display: grid;</code></pre>
                            Cela permet une mise en page en grille.
                        </li>
                        <li class="list-group-item">
                            <strong>position</strong> : Définit le type de positionnement d'un élément. Par exemple :
                            <pre><code>position: static;</code></pre>
                            C'est le positionnement par défaut. Autres exemples :
                            <pre><code>position: relative;</code></pre>
                            Cela permet de positionner l'élément par rapport à sa position normale.
                            <pre><code>position: absolute;</code></pre>
                            Cela positionne l'élément par rapport à son conteneur le plus proche positionné.
                            <pre><code>position: fixed;</code></pre>
                            Cela positionne l'élément par rapport à la fenêtre du navigateur.
                        </li>
                        <li class="list-group-item">
                            <strong>top / right / bottom / left</strong> : Définit la position d'un élément par rapport à son conteneur de positionnement. Par exemple :
                            <pre>
                            <code>
position: absolute;
top: 10px;
left: 20px;
                                </code>
                            </pre>
                            Cela déplace l'élément de 10 pixels vers le bas et de 20 pixels vers la droite par rapport à son conteneur.
                        </li>
                        <li class="list-group-item">
                            <strong>float</strong> : Utilisé pour aligner un élément à gauche ou à droite dans son conteneur. Par exemple :
                            <pre><code>float: left;</code></pre>
                            Cela aligne l'élément à gauche et permet d'enrouler le texte autour de lui.
                        </li>
                        <li class="list-group-item">
                            <strong>flexbox</strong> : Modèle de mise en page qui permet d'aligner des éléments dans un conteneur flexible. Par exemple :
                            <pre>
                            <code>
display: flex;
justify-content: center;
align-items: center;
                                </code>
                            </pre>
                            Cela centre les éléments horizontalement et verticalement dans le conteneur.
                        </li>
                        <li class="list-group-item">
                            <strong>grid</strong> : Système de grille pour la mise en page, permettant de placer des éléments dans des lignes et colonnes. Par exemple :
                            <pre>
                            <code>
display: grid;
grid-template-columns: repeat(3, 1fr);
grid-template-rows: auto;
                                </code>
                            </pre>
                            Cela crée une grille avec trois colonnes de largeur égale et des lignes de hauteur automatique.
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Animation et Transition -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#animationSection" aria-expanded="false" aria-controls="animationSection">
                    Animation et Transition
                </button>
            </h2>
            <div id="animationSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>transition</strong> : Définit la manière dont les changements de propriétés CSS sont animés (ex: durée et type de transition). Par exemple :
                            <pre>
                            <code>
transition: all 0.3s ease;
                                </code>
                            </pre>
                            Cela signifie que tous les changements de propriétés seront animés sur une durée de 0.3 secondes avec une courbe de transition <code>ease</code>.
                        </li>
                        <li class="list-group-item">
                            <strong>animation</strong> : Permet de définir des animations en utilisant des images clés (keyframes). Par exemple :
                            <pre>
                            <code>
animation: slide 2s infinite;
                                </code>
                            </pre>
                            Cela signifie que l'animation nommée <code>slide</code> durera 2 secondes et se répétera indéfiniment.
                        </li>
                        <li class="list-group-item">
                            <strong>keyframes</strong> : Définit les étapes de l'animation avec des points clés où des changements de style se produisent. Par exemple :
                            <pre>
                            <code>
&#64keyframes slide {
    from { left: 0; }
    to { left: 100px; }
}
                                </code>
                            </pre>
                            Cela définit une animation où un élément se déplace de 0 à 100 pixels vers la droite.
                        </li>
                        <li class="list-group-item">
                            <strong>transform</strong> : Applique des transformations à un élément comme la rotation, le redimensionnement, ou la translation. Par exemple :
                            <pre>
                            <code>
transform: rotate(45deg);
                                </code>
                            </pre>
                            Cela fait pivoter l'élément de 45 degrés. Un autre exemple :
                            <pre>
                            <code>
transform: scale(1.5);
                                </code>
                            </pre>
                            Cela agrandit l'élément de 1.5 fois sa taille originale.
                        </li>
                        <li class="list-group-item">
                            <strong>transition-delay</strong> : Définit le délai avant que la transition ne commence. Par exemple :
                            <pre>
                            <code>
transition-delay: 0.5s;
                                </code>
                            </pre>
                            Cela signifie que la transition commencera 0.5 secondes après le déclenchement du changement de propriété.
                        </li>
                        <li class="list-group-item">
                            <strong>transition-timing-function</strong> : Contrôle le comportement de l'animation dans le temps (ex: <code>ease</code>, <code>linear</code>). Par exemple :
                            <pre>
                            <code>
transition-timing-function: ease;
                                </code>
                            </pre>
                            Cela commence lentement, accélère, puis ralentit à nouveau. Un autre exemple :
                            <pre>
                            <code>
transition-timing-function: linear;
                                </code>
                            </pre>
                            Cela maintient une vitesse constante tout au long de la transition.
                        </li>
                    </ul>
                </div>
            </div>
        </div>

    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire JavaScript</h1>

    <div class="accordion">
        <!-- Section Variables et Types de Données -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#variablesSection" aria-expanded="false" aria-controls="variablesSection">
                    Variables et Types de Données
                </button>
            </h2>
            <div id="variablesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>var</strong> : Déclare une variable globale ou locale à une fonction. La portée de la variable est la fonction entière, même si elle est déclarée dans un bloc. Par exemple :
                            <pre>
                            <code>
function exemple() {
    if (true) {
        var x = 10;
    }
    console.log(x); // 10, car var est fonctionnelle
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>let</strong> : Déclare une variable à portée de bloc. Utilisé pour éviter les hoistings, ce qui signifie que la variable n'est accessible que dans le bloc où elle est déclarée. Par exemple :
                            <pre>
                            <code>
function exemple() {
    if (true) {
        let y = 20;
        console.log(y); // 20
    }
    console.log(y); // Erreur, y n'est pas défini
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>const</strong> : Déclare une constante, une variable dont la valeur ne peut pas être réassignée. La portée est également limitée au bloc où elle est déclarée. Par exemple :
                            <pre>
                            <code>
function exemple() {
    const z = 30;
    console.log(z); // 30
    z = 40; // Erreur, z ne peut pas être réassigné
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>String</strong> : Type de donnée utilisé pour représenter du texte. Les chaînes de caractères peuvent être créées en utilisant des guillemets simples ou doubles. Par exemple :
                            <pre>
                            <code>
let texte = "Bonjour";
let autreTexte = 'Salut';
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Number</strong> : Type de donnée pour représenter des nombres, qu'ils soient entiers ou à virgule flottante. Par exemple :
                            <pre>
                            <code>
let entier = 42;
let flottant = 3.14;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Boolean</strong> : Type de donnée logique qui peut être <code>true</code> ou <code>false</code>. Utilisé pour les conditions et les comparaisons. Par exemple :
                            <pre>
                            <code>
let estVrai = true;
let estFaux = false;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Array</strong> : Collection d'éléments, qui peuvent être de n'importe quel type. Les éléments sont accessibles par leur index. Par exemple :
                            <pre>
                            <code>
let tableau = [1, 2, 3];
console.log(tableau[0]); // 1
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Object</strong> : Collection de paires clé-valeur, où chaque clé est une chaîne de caractères et chaque valeur peut être de n'importe quel type. Par exemple :
                            <pre>
                            <code>
let personne = { nom: "Alice", âge: 25 };
console.log(personne.nom); // Alice
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>null</strong> : Valeur spéciale représentant l'absence de valeur. Utilisé pour indiquer qu'une variable n'a pas de valeur assignée. Par exemple :
                            <pre>
                            <code>
let a = null;
console.log(a); // null
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>undefined</strong> : Représente une variable qui a été déclarée mais n'a pas encore de valeur. Par exemple :
                            <pre>
                            <code>
let b;
console.log(b); // undefined
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Fonctions -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#functionsSection" aria-expanded="false" aria-controls="functionsSection">
                    Fonctions
                </button>
            </h2>
            <div id="functionsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>function</strong> : Déclare une fonction qui peut être appelée plus tard. Par exemple :
                            <pre>
                            <code>
function maFonction() {
    // Code de la fonction
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>return</strong> : Instruction qui termine une fonction et renvoie une valeur. Par exemple :
                            <pre>
                            <code>
function addition(a, b) {
    return a + b;
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>arrow function</strong> : Syntaxe concise pour définir des fonctions anonymes. Par exemple :
                            <pre>
                            <code>
const addition = (a, b) => a + b;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>callback</strong> : Fonction passée en argument à une autre fonction et exécutée après une opération. Par exemple :
                            <pre>
                            <code>
function traitementAsynchrone(callback) {
    setTimeout(() => {
        // Opération asynchrone terminée
        callback();
    }, 1000);
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>closure</strong> : Fonction ayant accès aux variables de son contexte extérieur, même après que cette fonction ait été exécutée. Par exemple :
                            <pre>
                            <code>
function createCounter() {
    let count = 0;
    return function() {
        count++;
    return count;
    };
}
const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>async / await</strong> : Mots-clés pour gérer les opérations asynchrones dans JavaScript. Par exemple :
                            <pre>
                            <code>
async function fetchData() {
    let response = await fetch('https://api.example.com/data');
    let data = await response.json();
    console.log(data);
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Boucles et Conditions -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#loopsConditionsSection" aria-expanded="false" aria-controls="loopsConditionsSection">
                    Boucles et Conditions
                </button>
            </h2>
            <div id="loopsConditionsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">

                        `
                        <li class="list-group-item">
                            <strong>if / else</strong> : Exécute un bloc de code si une condition est vraie, et un autre bloc si elle est fausse. Par exemple :
                            <pre>
                            <code>
if (condition) {
    // Code à exécuter si la condition est vraie
} else {
    // Code à exécuter si la condition est fausse
}
                        </code>
                        </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>switch</strong> : Évalue une expression et exécute un bloc de code correspondant à la valeur de l'expression. Par exemple :
                            <pre>
                            <code>
switch (expression) {
    case valeur1:
        // Code à exécuter si l'expression vaut valeur1
    break;
    case valeur2:
        // Code à exécuter si l'expression vaut valeur2
    break;
    default:
        // Code à exécuter si aucune des valeurs ne correspond
}
                        </code>
                        </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>for</strong> : Boucle qui s'exécute un nombre défini de fois. Par exemple :
                            <pre>
                            <code>
for (int i = 0; i &lt; n; i++) {
    // Code à exécuter n fois
}
                        </code>
                        </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>while</strong> : Boucle qui s'exécute tant qu'une condition est vraie. Par exemple :
                            <pre>
                            <code>
while (condition) {
    // Code à exécuter tant que la condition est vraie
}
                        </code>
                        </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>forEach</strong> : Méthode qui exécute une fonction pour chaque élément d'un tableau. Par exemple :
                            <pre>
                            <code>
array.forEach(element => {
    // Code à exécuter pour chaque élément
});
                        </code>
                        </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>map</strong> : Méthode qui crée un nouveau tableau en appelant une fonction sur chaque élément du tableau d'origine. Par exemple :
                            <pre>
                            <code>
let newArray = array.map(element => {
    // Transformation de chaque élément
    return newElement;
});
                        </code>
                        </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Manipulation du DOM -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#domSection" aria-expanded="false" aria-controls="domSection">
                    Manipulation du DOM
                </button>
            </h2>
            <div id="domSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>document.getElementById()</strong> : Récupère un élément HTML par son ID. Par exemple :
                            <pre>
                            <code>
let element = document.getElementById("monId");
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>document.querySelector()</strong> : Sélectionne le premier élément qui correspond à un sélecteur CSS donné. Par exemple :
                            <pre>
                            <code>
let element = document.querySelector(".maClasse");
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>innerHTML</strong> : Propriété qui permet de définir ou récupérer le contenu HTML d'un élément. Par exemple :
                            <pre>
                            <code>
element.innerHTML = "Nouveau contenu";
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>addEventListener()</strong> : Attache un gestionnaire d'événements à un élément. Par exemple :
                            <pre>
                            <code>
element.addEventListener("click", function() {
    // Code à exécuter lors du clic
});
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>removeEventListener()</strong> : Supprime un gestionnaire d'événements d'un élément. Par exemple :
                            <pre>
                            <code>
element.removeEventListener("click", maFonction);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>createElement()</strong> : Crée un nouvel élément HTML. Par exemple :
                            <pre>
                            <code>
let newElement = document.createElement("div");
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>appendChild()</strong> : Ajoute un élément enfant à un élément parent. Par exemple :
                            <pre>
                            <code>
parentElement.appendChild(newElement);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>removeChild()</strong> : Supprime un élément enfant d'un élément parent. Par exemple :
                            <pre>
                            <code>
parentElement.removeChild(childElement);
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Asynchrone et Promesses -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#asyncPromisesSection" aria-expanded="false" aria-controls="asyncPromisesSection">
                    Asynchrone et Promesses
                </button>
            </h2>
            <div id="asyncPromisesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Promise</strong> : Objet représentant une opération asynchrone et ses résultats futurs. Par exemple :
                            <pre>
                            <code>
let promise = new Promise((resolve, reject) => {
    // Opération asynchrone
    if (succès) {
        resolve(résultat);
    } 
    else {
        reject(erreur);
    }
});
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>then()</strong> : Méthode appelée lorsque la promesse est résolue. Par exemple :
                            <pre>
                            <code>
promise.then(résultat => {
    // Code à exécuter lorsque la promesse est résolue
});
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>catch()</strong> : Méthode appelée lorsque la promesse est rejetée ou qu'une erreur est survenue. Par exemple :
                            <pre>
                            <code>
promise.catch(erreur => {
    // Code à exécuter lorsque la promesse est rejetée
});
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>async</strong> : Mot-clé qui permet d'écrire des fonctions asynchrones en JavaScript. Par exemple :
                            <pre>
                            <code>
async function maFonction() {
    // Code asynchrone
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>await</strong> : Mot-clé utilisé pour attendre la résolution d'une promesse dans une fonction <code>async</code>. Par exemple :
                            <pre>
                            <code>
async function maFonction() {
    let résultat = await promise;
    // Code à exécuter après la résolution de la promesse
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>setTimeout()</strong> : Fonction qui exécute du code après un délai spécifié. Par exemple :
                            <pre>
                            <code>
setTimeout(() => {
    // Code à exécuter après le délai
}, délaiEnMillisecondes);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>setInterval()</strong> : Fonction qui exécute du code à intervalles réguliers. Par exemple :
                            <pre>
                            <code>
setInterval(() => {
// Code à exécuter à chaque intervalle
}, intervalleEnMillisecondes);
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire TypeScript</h1>

    <div class="accordion">
        <!-- Section Typage -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#typesSection" aria-expanded="false" aria-controls="typesSection">
                    Typage en TypeScript
                </button>
            </h2>
            <div id="typesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>any</strong> : Type qui permet à une variable de contenir n'importe quelle valeur. Utilisé lorsque le type de la variable n'est pas connu à l'avance. Exemple :
                            <pre>
                            <code>
let value: any = "Hello";
value = 42; // Changement de type possible
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>string</strong> : Type utilisé pour les chaînes de caractères. Exemple :
                            <pre><code>let name: string = "Alice";</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>number</strong> : Type utilisé pour les nombres. Peut représenter des entiers et des nombres à virgule flottante. Exemple :
                            <pre><code>let age: number = 30;</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>boolean</strong> : Type utilisé pour représenter des valeurs booléennes (<code>true</code> ou <code>false</code>). Exemple :
                            <pre><code>let isActive: boolean = true;</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>void</strong> : Type utilisé pour les fonctions qui ne renvoient pas de valeur. Exemple :
                            <pre>
                            <code>
function logMessage(message: string): void {
    console.log(message);
}       
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>null / undefined</strong> : Types représentant une absence de valeur. <code>null</code> est utilisé pour indiquer une valeur intentionnellement absente, tandis que <code>undefined</code> signifie qu'une variable n'a pas été initialisée. Exemple :
                            <pre>
                            <code>
let value: null = null;
let notInitialized: undefined = undefined;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>array</strong> : Tableau typé, défini par exemple avec <code>number[]</code> ou <code>Array&lt;number&gt;</code>. Utilisé pour stocker une collection d'éléments du même type. Exemple :
                            <pre><code>let numbers: number[] = [1, 2, 3, 4, 5];</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>tuple</strong> : Tableau à longueur fixe, où chaque élément peut avoir un type différent. Utilisé pour représenter un ensemble de valeurs de types différents. Exemple :
                            <pre><code>let person: [string, number] = ["Alice", 30];</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>enum</strong> : Énumération qui permet de définir un ensemble de valeurs nommées. Utilisé pour représenter un ensemble de valeurs constantes. Exemple :
                            <pre>
                            <code>
enum Color {
    Red,
    Green,
    Blue
}
let color: Color = Color.Green;
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Fonctions -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#functionsSection" aria-expanded="false" aria-controls="functionsSection">
                    Fonctions en TypeScript
                </button>
            </h2>
            <div id="functionsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>type des paramètres</strong> : Vous pouvez spécifier le type des paramètres d'une fonction pour garantir que les arguments passés sont du type attendu. Exemple :
                            <pre>
                            <code>
function greet(name: string): void {
    console.log("Hello, " + name);
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>type de retour</strong> : Vous pouvez spécifier le type de retour d'une fonction pour indiquer le type de valeur que la fonction renvoie. Exemple :
                            <pre>
                            <code>
function sum(a: number, b: number): number {
    return a + b;
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>paramètres optionnels</strong> : Utilisez le point d'interrogation (<code>?</code>) pour indiquer qu'un paramètre est optionnel. Si le paramètre n'est pas fourni, il sera <code>undefined</code>. Exemple :
                            <pre>
                            <code>
function log(message?: string): void {
    if (message) {
        console.log(message);
    } else {
        console.log("No message provided");
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>paramètres par défaut</strong> : Permet de définir une valeur par défaut pour un paramètre. Si aucun argument n'est passé pour ce paramètre, la valeur par défaut sera utilisée. Exemple :
                            <pre>
                            <code>
function increment(n: number = 1): number {
    return n + 1;
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>rest parameters</strong> : Utilisez <code>...</code> pour représenter un nombre variable d'arguments. Les rest parameters sont regroupés dans un tableau. Exemple :
                            <pre>
                            <code>
function sum(...numbers: number[]): number {
    return numbers.reduce((acc, curr) => acc + curr, 0);
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Interfaces et Types -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#interfacesSection" aria-expanded="false" aria-controls="interfacesSection">
                    Interfaces et Types
                </button>
            </h2>
            <div id="interfacesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>interface</strong> : Déclare une forme que doivent respecter des objets ou des classes. Utilisé pour définir un contrat que les objets doivent respecter. Exemple :
                            <pre>
                            <code>
interface Person {
    name: string;
    age: number;
}
let alice: Person = { name: "Alice", age: 30 };
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>type alias</strong> : Permet de créer un nom pour un type existant. Utilisé pour simplifier les types complexes ou pour donner des noms significatifs aux types. Exemple :
                            <pre>
                            <code>
type ID = string | number;
let userId: ID = "12345"; // Peut être une chaîne ou un nombre
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>readonly</strong> : Propriété ou paramètre qui ne peut pas être modifié après initialisation. Utilisé pour créer des propriétés immuables. Exemple :
                            <pre>
                            <code>
interface Person {
    readonly id: number;
    name: string;
}
let alice: Person = { id: 1, name: "Alice" };
// alice.id = 2; // Erreur : id est en lecture seule
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>optional properties</strong> : Propriétés optionnelles dans une interface. Utilisé pour indiquer qu'une propriété peut ou non être présente. Exemple :
                            <pre>
                            <code>
interface Person {
    name: string;
    age?: number; // Propriété optionnelle
}
let alice: Person = { name: "Alice" }; // age est optionnel
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>index signatures</strong> : Permet de définir des types dynamiques pour les clés d'objets. Utilisé pour représenter des objets avec des clés dynamiques. Exemple :
                            <pre>
                            <code>
interface StringArray {
    [index: number]: string;
}
let myArray: StringArray = ["Alice", "Bob"];
let firstElement: string = myArray[0]; // Accède au premier élément
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Classes -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#classesSection" aria-expanded="false" aria-controls="classesSection">
                    Classes en TypeScript
                </button>
            </h2>
            <div id="classesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>class</strong> : Déclare une classe avec des propriétés et des méthodes. Utilisé pour créer des objets avec des propriétés et des comportements définis. Exemple :
                            <pre>
                            <code>
class Person {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    greet() {
        console.log("Hello, " + this.name);
    }
}
let alice = new Person("Alice");
alice.greet(); // Affiche "Hello, Alice"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>constructor</strong> : Méthode spéciale utilisée pour créer une instance d'une classe. Initialise les propriétés de l'objet. Exemple :
                            <pre>
                            <code>
class Person {
    name: string;
    constructor(name: string) {
    this.name = name;
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>public / private / protected</strong> : Modificateurs d'accès pour les membres d'une classe. <code>public</code> est accessible partout, <code>private</code> est accessible uniquement à l'intérieur de la classe, et <code>protected</code> est accessible dans la classe et ses sous-classes. Exemple :
                            <pre>
                            <code>
class Person {
    public name: string;
    private age: number;
    protected address: string;
    constructor(name: string, age: number, address: string) {
        this.name = name;
        this.age = age;
        this.address = address;
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>readonly</strong> : Propriétés qui ne peuvent pas être modifiées après leur initialisation. Utilisé pour créer des propriétés immuables. Exemple :
                            <pre>
                            <code>
class Person {
    readonly id: number;
    name: string;
    constructor(id: number, name: string) {
        this.id = id;
        this.name = name;
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>static</strong> : Définit des membres de classe qui sont partagés entre toutes les instances de la classe. Utilisé pour des propriétés ou des méthodes qui appartiennent à la classe elle-même plutôt qu'à une instance spécifique. Exemple :
                            <pre>
                            <code>
class Counter {
    static count: number = 0;
    static increment() {
        Counter.count++;
    }
}
Counter.increment();
console.log(Counter.count); // Affiche 1
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>extends</strong> : Utilisé pour hériter d'une autre classe. Permet à une classe de dériver d'une autre classe et de réutiliser ses propriétés et méthodes. Exemple :
                            <pre>
                            <code>
class Employee extends Person {
    constructor(name: string, age: number, address: string, public jobTitle: string) {
        super(name, age, address);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>super</strong> : Permet d'appeler le constructeur ou les méthodes d'une classe parente dans une classe enfant. Utilisé pour accéder aux membres de la classe parente. Exemple :
                            <pre>
                            <code>
class Employee extends Person {
    constructor(name: string, age: number, address: string, public jobTitle: string) {
        super(name, age, address);
    }
    displayJobTitle() {
        console.log(this.jobTitle);
    }
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Génériques -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#genericsSection" aria-expanded="false" aria-controls="genericsSection">
                    Génériques en TypeScript
                </button>
            </h2>
            <div id="genericsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>génériques</strong> : Permettent de créer des fonctions ou classes qui peuvent fonctionner avec plusieurs types. Utilisé pour écrire du code réutilisable et type-safe. Exemple :
                            <pre>
                            <code>
function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let output1 = identity&lt;string>("Hello"); // Utilise 'string' comme type
let output2 = identity&lt;number>(42); // Utilise 'number' comme type
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>génériques contraints</strong> : Restreignent les types utilisés avec des génériques. Utilisé pour imposer des contraintes sur les types génériques afin de garantir qu'ils possèdent certaines propriétés ou méthodes. Exemple :
                            <pre>
                            <code>
function logLength&lt;T extends { length: number }&gt;(arg: T): void {
    console.log(arg.length);
}
logLength("Hello"); // Fonctionne car 'string' a une propriété 'length'
logLength([1, 2, 3]); // Fonctionne car 'array' a une propriété 'length'
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>génériques dans les classes</strong> : Utilisation des génériques dans les classes pour rendre les méthodes et propriétés plus flexibles. Utilisé pour créer des classes réutilisables et type-safe. Exemple :
                            <pre>
                            <code>
class GenericNumber&lt;T&gt; {
    zeroValue: T;
    add: (x: T, y: T) =&gt; T;
}
let myGenericNumber = new GenericNumber&lt;number&gt;();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = (x, y) => x + y;
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire Bootstrap</h1>

    <div class="accordion">
        <!-- Section Grille Bootstrap -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#gridSystemSection" aria-expanded="false" aria-controls="gridSystemSection">
                    Système de Grille Bootstrap
                </button>
            </h2>
            <div id="gridSystemSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>container</strong> : Élément de conteneur central qui contient et centre le contenu dans la grille Bootstrap. Utilisé pour créer une mise en page réactive et aligner le contenu de manière cohérente. Exemple :
                            <pre>
                            <code>
&lt;div class="container"&gt;
    &lt;h1&gt;Bienvenue&lt;/h1&gt;
    &lt;p&gt;Ceci est un conteneur Bootstrap.&lt;/p&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>row</strong> : Définit une rangée dans la grille Bootstrap pour organiser les colonnes. Utilisé pour aligner les colonnes horizontalement. Exemple :
                            <pre>
                            <code>
&lt;div class="container"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col"&gt;
            Colonne 1
        &lt;/div&gt;
        &lt;div class="col"&gt;
            Colonne 2
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>col</strong> : Définit une colonne dans la grille. Bootstrap utilise un système de grille à 12 colonnes, et vous pouvez ajuster la largeur en utilisant des classes comme <code>.col-6</code> (largeur de 6 colonnes sur 12). Utilisé pour créer des mises en page réactives. Exemple :
                            <pre>
                            <code>
&lt;div class="container"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-6"&gt;
            Colonne de 6 unités
        &lt;/div&gt;
        &lt;div class="col-6"&gt;
            Colonne de 6 unités
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>col-sm, col-md, col-lg, col-xl</strong> : Classes de colonnes qui ajustent la largeur des colonnes en fonction de la taille de l'écran. Par exemple, <code>col-md-6</code> prendra la moitié de la largeur d'une rangée sur un écran de taille moyenne ou plus grand. Utilisé pour créer des mises en page réactives adaptées à différentes tailles d'écran. Exemple :
                            <pre>
                            <code>
&lt;div class="container"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-sm-12 col-md-6 col-lg-4"&gt;
            Colonne réactive
        &lt;/div&gt;
        &lt;div class="col-sm-12 col-md-6 col-lg-8"&gt;
            Colonne réactive
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>offset</strong> : Décale une colonne par un certain nombre de colonnes, par exemple <code>.offset-md-3</code> décale une colonne de 3 unités sur un écran moyen. Utilisé pour créer des espaces vides à gauche des colonnes. Exemple :
                            <pre>
                            <code>
&lt;div class="container"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-md-6 offset-md-3"&gt;
            Colonne décalée de 3 unités
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Typographie -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#typographySection" aria-expanded="false" aria-controls="typographySection">
                    Typographie
                </button>
            </h2>
            <div id="typographySection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>h1, h2, h3, h4, h5, h6</strong> : Classes de titres qui correspondent aux balises HTML de titres respectifs. Utilisé pour appliquer des styles Bootstrap aux titres. Exemple :
                            <pre>
                            <code>
&lt;h1 class="h1"&gt;Titre Principal&lt;/h1&gt;
&lt;h2 class="h2"&gt;Sous-titre&lt;/h2&gt;
&lt;h3 class="h3"&gt;Sous-sous-titre&lt;/h3&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>display-1, display-2, ... display-6</strong> : Classes pour des titres plus grands et plus audacieux que les balises <code>&lt;h1&gt;</code> à <code>&lt;h6&gt;</code>. Utilisé pour attirer l'attention sur des titres importants. Exemple :
                            <pre>
                            <code>
&lt;h1 class="display-1"&gt;Titre Affichage 1&lt;/h1&gt;
&lt;h2 class="display-2"&gt;Titre Affichage 2&lt;/h2&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>lead</strong> : Utilisé pour les textes introductifs plus grands, souvent un paragraphe de description. Exemple :
                            <pre>
                            <code>
&lt;p class="lead"&gt;Ceci est un texte introductif plus grand.&lt;/p&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>text-center, text-left, text-right</strong> : Aligne le texte au centre, à gauche, ou à droite respectivement. Utilisé pour contrôler l'alignement du texte. Exemple :
                            <pre>
                            <code>
&lt;p class="text-center"&gt;Texte centré&lt;/p&gt;
&lt;p class="text-left"&gt;Texte aligné à gauche&lt;/p&gt;
&lt;p class="text-right"&gt;Texte aligné à droite&lt;/p&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>text-muted</strong> : Utilisé pour rendre le texte plus discret ou plus pâle. Exemple :
                            <pre>
                            <code>
&lt;p class="text-muted"&gt;Texte en sourdine&lt;/p&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>blockquote</strong> : Utilisé pour styliser les citations avec un retrait par rapport au texte normal. Exemple :
                            <pre>
                            <code>
&lt;blockquote class="blockquote"&gt;
    &lt;p class="mb-0"&gt;Ceci est une citation.&lt;/p&gt;
    &lt;footer class="blockquote-footer"&gt;Source de la citation&lt;/footer&gt;
&lt;/blockquote&gt;
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Boutons -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#buttonsSection" aria-expanded="false" aria-controls="buttonsSection">
                    Boutons
                </button>
            </h2>
            <div id="buttonsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>btn</strong> : Classe de base utilisée pour styliser les boutons Bootstrap. Utilisé pour appliquer des styles de base aux boutons. Exemple :
                            <pre>
                            <code>
&lt;button class="btn"&gt;Bouton&lt;/button&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>btn-primary</strong> : Utilisé pour styliser un bouton avec la couleur principale. Exemple :
                            <pre>
                            <code>
&lt;button class="btn btn-primary"&gt;Bouton Principal&lt;/button&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>btn-secondary, btn-success, btn-danger, btn-warning</strong> : Classes de boutons pour des couleurs spécifiques, telles que le succès (vert), l'avertissement (jaune), etc. Utilisé pour indiquer différentes actions ou états. Exemple :
                            <pre>
                            <code>
&lt;button class="btn btn-secondary"&gt;Bouton Secondaire&lt;/button&gt;
&lt;button class="btn btn-success"&gt;Bouton Succès&lt;/button&gt;
&lt;button class="btn btn-danger"&gt;Bouton Danger&lt;/button&gt;
&lt;button class="btn btn-warning"&gt;Bouton Avertissement&lt;/button&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>btn-outline-*</strong> : Versions des boutons qui n'ont que les contours stylisés, par exemple <code>btn-outline-primary</code> pour un bouton contour bleu. Utilisé pour des boutons moins proéminents. Exemple :
                            <pre>
                            <code>
&lt;button class="btn btn-outline-primary"&gt;Bouton Contour Bleu&lt;/button&gt;
&lt;button class="btn btn-outline-secondary"&gt;Bouton Contour Gris&lt;/button&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>btn-lg, btn-sm</strong> : Classes utilisées pour ajuster la taille d'un bouton (grande ou petite). Utilisé pour adapter les boutons à différentes tailles d'interface utilisateur. Exemple :
                            <pre>
                            <code>
&lt;button class="btn btn-primary btn-lg"&gt;Grand Bouton&lt;/button&gt;
&lt;button class="btn btn-primary btn-sm"&gt;Petit Bouton&lt;/button&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>btn-block</strong> : Utilisé pour rendre un bouton pleine largeur par rapport à son parent. Exemple :
                            <pre>
                            <code>
&lt;button class="btn btn-primary btn-block"&gt;Bouton Pleine Largeur&lt;/button&gt;
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Composants -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#componentsSection" aria-expanded="false" aria-controls="componentsSection">
                    Composants Bootstrap
                </button>
            </h2>
            <div id="componentsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Navbar</strong> : Barre de navigation en haut de la page, souvent utilisée pour les menus et les liens de navigation. Utilisé pour améliorer la navigation et l'accessibilité du site. Exemple :
                            <pre>
                            <code>
&lt;nav class="navbar navbar-expand-lg navbar-light bg-light"&gt;
    &lt;a class="navbar-brand" href="#"&gt;Brand&lt;/a&gt;
    &lt;button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"&gt;
        &lt;span class="navbar-toggler-icon"&gt;&lt;/span&gt;
    &lt;/button&gt;
    &lt;div class="collapse navbar-collapse" id="navbarNav"&gt;
        &lt;ul class="navbar-nav"&gt;
            &lt;li class="nav-item active"&gt;
                &lt;a class="nav-link" href="#"&gt;Home &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class="nav-item"&gt;
                &lt;a class="nav-link" href="#"&gt;Features&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class="nav-item"&gt;
                &lt;a class="nav-link" href="#"&gt;Pricing&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/nav&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Card</strong> : Composant contenant du contenu dans une boîte avec un en-tête, un corps et un pied de page optionnels. Utilisé pour afficher des informations de manière concise et visuellement attrayante. Exemple :
                            <pre>
                            <code>
&lt;div class="card" style="width: 18rem;"&gt;
    &lt;img src="image.jpg" class="card-img-top" alt="..."&gt;
    &lt;div class="card-body"&gt;
        &lt;h5 class="card-title"&gt;Card title&lt;/h5&gt;
        &lt;p class="card-text"&gt;Some quick example text to build on the card title and make up the bulk of the card's content.&lt;/p&gt;
        &lt;a href="#" class="btn btn-primary"&gt;Go somewhere&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Modal</strong> : Fenêtre modale superposée sur l'interface utilisateur pour afficher des informations supplémentaires ou pour des actions utilisateur. Utilisé pour attirer l'attention de l'utilisateur sur une tâche spécifique. Exemple :
                            <pre>
                            <code>
&lt;!-- Button trigger modal --&gt;
&lt;button type="button" class="btn btn-primary" data-toggle="modal" data-target="#exampleModal"&gt;
    Launch demo modal
&lt;/button&gt;

&lt;!-- Modal --&gt;
&lt;div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true"&gt;
    &lt;div class="modal-dialog"&gt;
        &lt;div class="modal-content"&gt;
            &lt;div class="modal-header"&gt;
                &lt;h5 class="modal-title" id="exampleModalLabel"&gt;Modal title&lt;/h5&gt;
                &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;
                    &lt;span aria-hidden="true"&gt;&times;&lt;/span&gt;
                &lt;/button&gt;
            &lt;/div&gt;
            &lt;div class="modal-body"&gt;
                ...
            &lt;/div&gt;
            &lt;div class="modal-footer"&gt;
                &lt;button type="button" class="btn btn-secondary" data-dismiss="modal"&gt;Close&lt;/button&gt;
                &lt;button type="button" class="btn btn-primary"&gt;Save changes&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Alert</strong> : Boîte de notification pour informer l'utilisateur d'une action ou d'un message important. Utilisé pour afficher des messages de succès, d'erreur, ou d'avertissement. Exemple :
                            <pre>
                            <code>
&lt;div class="alert alert-warning" role="alert"&gt;
    This is a warning alert—check it out!
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Badge</strong> : Petit composant indiquant un nombre ou une étiquette, généralement utilisé à côté des liens ou des boutons. Utilisé pour afficher des notifications ou des informations supplémentaires. Exemple :
                            <pre>
                            <code>
&lt;button type="button" class="btn btn-primary"&gt;
    Notifications &lt;span class="badge badge-light"&gt;4&lt;/span&gt;
&lt;/button&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Dropdown</strong> : Menu déroulant pour afficher des options supplémentaires ou des actions sur un bouton ou un lien. Utilisé pour organiser les options de manière compacte. Exemple :
                            <pre>
                            <code>
&lt;div class="dropdown"&gt;
    &lt;button class="btn btn-secondary dropdown-toggle" type="button" id="dropdownMenuButton" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"&gt;
        Dropdown button
    &lt;/button&gt;
    &lt;div class="dropdown-menu" aria-labelledby="dropdownMenuButton"&gt;
        &lt;a class="dropdown-item" href="#"&gt;Action&lt;/a&gt;
        &lt;a class="dropdown-item" href="#"&gt;Another action&lt;/a&gt;
        &lt;a class="dropdown-item" href="#"&gt;Something else here&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Accordion</strong> : Composant d'affichage en accordéon où un élément est déplié à la fois, utilisé pour afficher ou masquer du contenu. Utilisé pour organiser le contenu de manière compacte et interactive. Exemple :
                            <pre>
                            <code>
&lt;div class="accordion" id="accordionExample"&gt;
    &lt;div class="card"&gt;
        &lt;div class="card-header" id="headingOne"&gt;
            &lt;h2 class="mb-0"&gt;
                &lt;button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne"&gt;
                    Collapsible Group Item #1
                &lt;/button&gt;
            &lt;/h2&gt;
        &lt;/div&gt;

        &lt;div id="collapseOne" class="collapse show" aria-labelledby="headingOne" data-parent="#accordionExample"&gt;
            &lt;div class="card-body"&gt;
                Some placeholder content for the first accordion panel. This panel is shown by default, thanks to the &lt;code&gt;.show&lt;/code&gt; class.
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="card"&gt;
        &lt;div class="card-header" id="headingTwo"&gt;
            &lt;h2 class="mb-0"&gt;
                &lt;button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo"&gt;
                    Collapsible Group Item #2
                &lt;/button&gt;
            &lt;/h2&gt;
        &lt;/div&gt;
        &lt;div id="collapseTwo" class="collapse" aria-labelledby="headingTwo" data-parent="#accordionExample"&gt;
            &lt;div class="card-body"&gt;
                Some placeholder content for the second accordion panel. This panel is hidden by default.
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Carousel</strong> : Composant pour afficher une série d'éléments (images ou contenus) sous forme de diaporama. Utilisé pour présenter plusieurs éléments de manière interactive et attrayante. Exemple :
                            <pre>
                            <code>
&lt;div id="carouselExampleIndicators" class="carousel slide" data-ride="carousel"&gt;
    &lt;ol class="carousel-indicators"&gt;
        &lt;li data-target="#carouselExampleIndicators" data-slide-to="0" class="active"&gt;&lt;/li&gt;
        &lt;li data-target="#carouselExampleIndicators" data-slide-to="1"&gt;&lt;/li&gt;
        &lt;li data-target="#carouselExampleIndicators" data-slide-to="2"&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;div class="carousel-inner"&gt;
        &lt;div class="carousel-item active"&gt;
            &lt;img class="d-block w-100" src="image1.jpg" alt="First slide"&gt;
        &lt;/div&gt;
        &lt;div class="carousel-item"&gt;
            &lt;img class="d-block w-100" src="image2.jpg" alt="Second slide"&gt;
        &lt;/div&gt;
        &lt;div class="carousel-item"&gt;
            &lt;img class="d-block w-100" src="image3.jpg" alt="Third slide"&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;a class="carousel-control-prev" href="#carouselExampleIndicators" role="button" data-slide="prev"&gt;
        &lt;span class="carousel-control-prev-icon" aria-hidden="true"&gt;&lt;/span&gt;
        &lt;span class="sr-only"&gt;Previous&lt;/span&gt;
    &lt;/a&gt;
    &lt;a class="carousel-control-next" href="#carouselExampleIndicators" role="button" data-slide="next"&gt;
        &lt;span class="carousel-control-next-icon" aria-hidden="true"&gt;&lt;/span&gt;
        &lt;span class="sr-only"&gt;Next&lt;/span&gt;
    &lt;/a&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Formulaires -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#formsSection" aria-expanded="false" aria-controls="formsSection">
                    Formulaires
                </button>
            </h2>
            <div id="formsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>form-control</strong> : Classe de base pour styliser les champs de saisie tels que <code>&lt;input&gt;</code> et <code>&lt;textarea&gt;</code>. Utilisé pour rendre les champs de saisie plus attrayants et uniformes. Exemple :
                            <pre>
                            <code>
&lt;input type="text" class="form-control" placeholder="Entrez votre nom"&gt;
&lt;textarea class="form-control" rows="3" placeholder="Entrez votre message"&gt;&lt;/textarea&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>form-group</strong> : Utilisé pour regrouper des champs de saisie avec des étiquettes et autres éléments connexes dans un formulaire. Utilisé pour organiser les champs de saisie de manière structurée. Exemple :
                            <pre>
                            <code>
&lt;div class="form-group"&gt;
    &lt;label for="exampleInputEmail1"&gt;Adresse email&lt;/label&gt;
    &lt;input type="email" class="form-control" id="exampleInputEmail1" aria-describedby="emailHelp" placeholder="Entrez votre email"&gt;
    &lt;small id="emailHelp" class="form-text text-muted"&gt;Nous ne partagerons jamais votre email avec quelqu'un d'autre.&lt;/small&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>form-check</strong> : Classe pour styliser les cases à cocher et les boutons radio. Utilisé pour rendre les cases à cocher et les boutons radio plus attrayants et uniformes. Exemple :
                            <pre>
                            <code>
&lt;div class="form-check"&gt;
    &lt;input class="form-check-input" type="checkbox" value="" id="defaultCheck1"&gt;
    &lt;label class="form-check-label" for="defaultCheck1"&gt;
        Option par défaut
    &lt;/label&gt;
&lt;/div&gt;
&lt;div class="form-check"&gt;
    &lt;input class="form-check-input" type="radio" name="exampleRadios" id="exampleRadios1" value="option1" checked&gt;
    &lt;label class="form-check-label" for="exampleRadios1"&gt;
        Première option
    &lt;/label&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>form-select</strong> : Classe pour styliser un menu déroulant <code>&lt;select&gt;</code>. Utilisé pour rendre les menus déroulants plus attrayants et uniformes. Exemple :
                            <pre>
                            <code>
&lt;select class="form-select" aria-label="Default select example"&gt;
    &lt;option selected&gt;Ouvrir ce menu de sélection&lt;/option&gt;
    &lt;option value="1"&gt;Un&lt;/option&gt;
    &lt;option value="2"&gt;Deux&lt;/option&gt;
    &lt;option value="3"&gt;Trois&lt;/option&gt;
&lt;/select&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>input-group</strong> : Utilisé pour regrouper un champ d'entrée avec des boutons ou des icônes (comme une barre de recherche avec un bouton de recherche). Utilisé pour créer des champs de saisie plus fonctionnels et interactifs. Exemple :
                            <pre>
                            <code>
&lt;div class="input-group mb-3"&gt;
    &lt;input type="text" class="form-control" placeholder="Rechercher"&gt;
    &lt;div class="input-group-append"&gt;
        &lt;button class="btn btn-outline-secondary" type="button"&gt;Bouton&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>form-floating</strong> : Classe pour styliser des champs de saisie avec des étiquettes flottantes à l'intérieur du champ. Utilisé pour créer des champs de saisie modernes et attrayants. Exemple :
                            <pre>
                            <code>
&lt;div class="form-floating mb-3"&gt;
    &lt;input type="email" class="form-control" id="floatingInput" placeholder="name@example.com"&gt;
    &lt;label for="floatingInput"&gt;Adresse email&lt;/label&gt;
&lt;/div&gt;
&lt;div class="form-floating"&gt;
    &lt;textarea class="form-control" placeholder="Laissez un commentaire ici" id="floatingTextarea"&gt;&lt;/textarea&gt;
    &lt;label for="floatingTextarea"&gt;Commentaires&lt;/label&gt;
&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Utilitaires -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#utilitiesSection" aria-expanded="false" aria-controls="utilitiesSection">
                    Utilitaires
                </button>
            </h2>
            <div id="utilitiesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>text-center, text-start, text-end</strong> : Utilitaires pour aligner le texte à gauche, au centre ou à droite. Utilisé pour contrôler l'alignement du texte dans les éléments. Exemple :
                            <pre>
                            <code>
&lt;p class="text-center"&gt;Texte centré&lt;/p&gt;
&lt;p class="text-start"&gt;Texte aligné à gauche&lt;/p&gt;
&lt;p class="text-end"&gt;Texte aligné à droite&lt;/p&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>bg-primary, bg-secondary</strong> : Classes de couleur d'arrière-plan pour les éléments (ex : bleu pour <code>bg-primary</code>). Utilisé pour appliquer des couleurs de fond prédéfinies aux éléments. Exemple :
                            <pre>
                            <code>
&lt;div class="bg-primary text-white"&gt;Fond bleu avec texte blanc&lt;/div&gt;
&lt;div class="bg-secondary text-white"&gt;Fond gris avec texte blanc&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>p-1, p-2, ... p-5</strong> : Classes pour définir le padding (espacement intérieur) d'un élément, où le chiffre correspond à la taille. Utilisé pour ajouter de l'espace à l'intérieur des éléments. Exemple :
                            <pre>
                            <code>
&lt;div class="p-1"&gt;Padding de 1 unité&lt;/div&gt;
&lt;div class="p-3"&gt;Padding de 3 unités&lt;/div&gt;
&lt;div class="p-5"&gt;Padding de 5 unités&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>m-1, m-2, ... m-5</strong> : Classes pour définir le margin (espacement extérieur) d'un élément. Utilisé pour ajouter de l'espace à l'extérieur des éléments. Exemple :
                            <pre>
                            <code>
&lt;div class="m-1"&gt;Margin de 1 unité&lt;/div&gt;
&lt;div class="m-3"&gt;Margin de 3 unités&lt;/div&gt;
&lt;div class="m-5"&gt;Margin de 5 unités&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>shadow-sm, shadow-lg</strong> : Classes pour ajouter des ombres aux éléments. Utilisé pour ajouter des effets d'ombre de différentes tailles aux éléments. Exemple :
                            <pre>
                            <code>
&lt;div class="shadow-sm p-3 mb-5 bg-white rounded"&gt;Petite ombre&lt;/div&gt;
&lt;div class="shadow-lg p-3 mb-5 bg-white rounded"&gt;Grande ombre&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>rounded, rounded-circle</strong> : Classes pour arrondir les angles d'un élément ou le transformer en cercle. Utilisé pour appliquer des coins arrondis ou des formes circulaires aux éléments. Exemple :
                            <pre>
                            <code>
&lt;div class="rounded p-3 mb-5 bg-white"&gt;Angles arrondis&lt;/div&gt;
&lt;div class="rounded-circle p-3 mb-5 bg-white"&gt;Forme circulaire&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>d-flex, d-block, d-none</strong> : Classes pour contrôler l'affichage des éléments (flexbox, block, none). Utilisé pour gérer la disposition et la visibilité des éléments. Exemple :
                            <pre>
                            <code>
&lt;div class="d-flex"&gt;Affichage en flexbox&lt;/div&gt;
&lt;div class="d-block"&gt;Affichage en block&lt;/div&gt;
&lt;div class="d-none"&gt;Affichage masqué&lt;/div&gt;
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-primary text-center mb-4">Vocabulaire de Programmation C#</h1>

    <div class="accordion">

        <!-- Types de données -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
                    1. Types de données (Data Types)
                </button>
            </h2>
            <div id="collapseOne" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <code>int</code> : Nombre entier (32 bits, plage de -2,147,483,648 à 2,147,483,647. Utilisé pour représenter des nombres entiers. Exemple :
                            <pre><code>int age = 30;</code></pre>
                        </li>
                        <li class="list-group-item">
                            <code>float</code> : Nombre à virgule flottante (précision simple, 32 bits, environ 7 chiffres significatifs. Utilisé pour représenter des nombres à virgule flottante avec une précision simple. Exemple :
                            <pre><code>float temperature = 36.6f;</code></pre>
                        </li>
                        <li class="list-group-item">
                            <code>double</code> : Nombre à virgule flottante (précision double, 64 bits, environ 15-16 chiffres significatifs. Utilisé pour représenter des nombres à virgule flottante avec une précision double. Exemple :
                            <pre><code>double distance = 12345.6789;</code></pre>
                        </li>
                        <li class="list-group-item">
                            <code>bool</code> : Valeur booléenne (<code>true</code> ou <code>false</code>, 1 bit. Utilisé pour représenter des valeurs booléennes. Exemple :
                            <pre><code>bool isActive = true;</code></pre>
                        </li>
                        <li class="list-group-item">
                            <code>string</code> : Chaîne de caractères (séquence de caractères Unicode, taille variable. Utilisé pour représenter des séquences de caractères. Exemple :
                            <pre><code>string name = "Alice";</code></pre>
                        </li>
                        <li class="list-group-item">
                            <code>char</code> : Caractère unique (16 bits, représente un caractère Unicode. Utilisé pour représenter un seul caractère. Exemple :
                            <pre><code>char initial = 'A';</code></pre>
                        </li>
                        <li class="list-group-item">
                            <code>decimal</code> : Nombre à virgule flottante de haute précision (128 bits, utilisé principalement pour les calculs financiers, environ 28-29 chiffres significatifs. Utilisé pour représenter des nombres à virgule flottante avec une haute précision, souvent utilisé dans les calculs financiers. Exemple :
                            <pre><code>decimal price = 19.99m;</code></pre>
                        </li>
                        <li class="list-group-item">
                            <code>var</code> : Inférence de type (le compilateur déduit le type de la variable à partir de l'expression assignée. Utilisé pour déclarer des variables sans spécifier explicitement leur type, le compilateur déduit le type à partir de l'expression assignée. Exemple :
                            <pre><code>var count = 10; // Le type de 'count' est déduit comme étant 'int'</code></pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Structures de contrôle -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                    2. Structures de contrôle (Control Structures)
                </button>
            </h2>
            <div id="collapseTwo" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <code>if</code>, <code>else if</code>, <code>else</code> : Conditions (permettent d'exécuter du code en fonction de la véracité d'une expression booléenne. Exemple :
                            <pre>
                            <code>
int number = 10;
if (number &gt; 0)
{
    Console.WriteLine("Positive number");
}
else if (number &lt; 0)
{
    Console.WriteLine("Negative number");
}
else
{
    Console.WriteLine("Zero");
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>switch</code>, <code>case</code> : Structure conditionnelle (permet de choisir parmi plusieurs blocs de code à exécuter en fonction de la valeur d'une expression. Exemple :
                            <pre>
                            <code>
int day = 3;
switch (day)
{
    case 1:
        Console.WriteLine("Monday");
        break;
    case 2:
        Console.WriteLine("Tuesday");
        break;
    case 3:
        Console.WriteLine("Wednesday");
        break;
    default:
        Console.WriteLine("Another day");
        break;
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>for</code>, <code>foreach</code> : Boucles pour itérer sur des collections (<code>for</code> utilise un compteur, <code>foreach</code> itère directement sur les éléments d'une collection. Exemple :
                            <pre>
                            <code>
// Boucle for
for (int i = 0; i &lt; 5; i++)
{
    Console.WriteLine(i);
}

// Boucle foreach
int[] numbers = { 1, 2, 3, 4, 5 };
foreach (int number in numbers)
{
    Console.WriteLine(number);
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>while</code>, <code>do-while</code> : Boucles (<code>while</code> continue tant qu'une condition est vraie, <code>do-while</code> exécute au moins une fois avant de vérifier la condition. Exemple :
                            <pre>
                            <code>
// Boucle while
int i = 0;
while (i &lt; 5)
{
    Console.WriteLine(i);
    i++;
}

// Boucle do-while
int j = 0;
do
{
    Console.WriteLine(j);
    j++;
} while (j &lt; 5);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>break</code> : Interruption d'une boucle ou d'un <code>switch</code> (arrête l'exécution de la boucle ou du <code>switch</code> en cours. Exemple :
                            <pre>
                            <code>
for (int i = 0; i &lt; 10; i++)
{
    if (i == 5)
    {
        break; // Interrompt la boucle lorsque i est égal à 5
    }
    Console.WriteLine(i);
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>continue</code> : Passer à l'itération suivante (saute le reste du code dans l'itération courante et passe à l'itération suivante de la boucle. Exemple :
                            <pre>
                            <code>
for (int i = 0; i &lt; 10; i++)
{
    if (i % 2 == 0)
    {
        continue; // Passe à l'itération suivante si i est pair
    }
    Console.WriteLine(i);
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Classes et Objets -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                    3. Classes et Objets (Classes and Objects)
                </button>
            </h2>
            <div id="collapseThree" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <code>class</code> : Déclaration d'une classe (modèle définissant les propriétés et les méthodes d'un objet. Exemple :
                            <pre>
                            <code>
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>object</code> : Instance d'une classe (représentation concrète d'une classe en mémoire. Exemple :
                            <pre>
                            <code>
Person person = new Person();
person.Name = "Alice";
person.Age = 30;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>constructor</code> : Méthode spéciale appelée lors de la création d'un objet (initialise les propriétés de l'objet. Exemple :
                            <pre>
                            <code>
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }

    // Constructeur
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>this</code> : Référence à l'instance actuelle (utilisée pour accéder aux membres de l'instance courante. Exemple :
                            <pre>
                            <code>
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }

    public Person(string name, int age)
    {
        this.Name = name;
        this.Age = age;
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>new</code> : Instancier un objet (crée une nouvelle instance d'une classe. Exemple :
                            <pre>
                            <code>
Person person = new Person("Alice", 30);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>static</code> : Membre partagé (appartient à la classe plutôt qu'à une instance spécifique. Exemple :
                            <pre>
                            <code>
public class MathUtilities
{
public static int Add(int a, int b)
    {
    return a + b;
    }
}

// Utilisation
int sum = MathUtilities.Add(5, 3);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>abstract</code> : Classe ou méthode abstraite (ne peut pas être instanciée directement, doit être héritée et implémentée. Exemple :
                            <pre>
                            <code>
public abstract class Animal
{
    public abstract void MakeSound();
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Woof");
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>interface</code> : Déclaration d'une interface (définit un contrat que les classes implémentant l'interface doivent respecter. Exemple :
                            <pre>
                            <code>
public interface IMovable
{
    void Move();
}

public class Car : IMovable
{
    public void Move()
    {
        Console.WriteLine("The car is moving");
    }
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Méthodes et Fonctions -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseFour" aria-expanded="false" aria-controls="collapseFour">
                    4. Méthodes et Fonctions (Methods and Functions)
                </button>
            </h2>
            <div id="collapseFour" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <code>void</code> : Méthode sans retour (ne renvoie aucune valeur, utilisée pour les actions qui ne nécessitent pas de résultat. Exemple :
                            <pre>
                            <code>
public void DisplayMessage()
{
    Console.WriteLine("Hello, World!");
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>return</code> : Retourner une valeur (met fin à l'exécution d'une méthode et renvoie une valeur à l'appelant. Exemple :
                            <pre>
                            <code>
public int Add(int a, int b)
{
    return a + b;
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>public</code>, <code>private</code>, <code>protected</code>, <code>internal</code> : Modificateurs d'accès (définissent la visibilité et l'accessibilité des membres d'une classe. Exemple :
                            <pre>
                            <code>
public class MyClass
{
    public int PublicProperty { get; set; } // Accessible partout
    private int PrivateProperty { get; set; } // Accessible uniquement dans cette classe
    protected int ProtectedProperty { get; set; } // Accessible dans cette classe et les classes dérivées
    internal int InternalProperty { get; set; } // Accessible dans le même assembly
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>params</code> : Paramètres variables (permet de passer un nombre variable d'arguments à une méthode. Exemple :
                            <pre>
                            <code>
public void PrintNumbers(params int[] numbers)
{
    foreach (int number in numbers)
    {
        Console.WriteLine(number);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>async</code> / <code>await</code> : Asynchrone (permet d'exécuter des opérations de manière asynchrone, sans bloquer le thread principal. Exemple :
                            <pre>
                            <code>
public async Task&lt;int&gt; GetDataAsync()
{
    await Task.Delay(1000); // Simule une opération asynchrone
    return 42;
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Collections et Tableaux -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseFive" aria-expanded="false" aria-controls="collapseFive">
                    5. Collections et Tableaux (Collections and Arrays)
                </button>
            </h2>
            <div id="collapseFive" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <code>Array[]</code> : Tableau (collection d'éléments de même type, taille fixe, accès rapide par index. Exemple :
                            <pre>
                            <code>
int[] numbers = new int[5]; // Déclare un tableau de 5 entiers
numbers[0] = 1; // Assigne la valeur 1 au premier élément
int firstNumber = numbers[0]; // Accède au premier élément
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>List&lt;T&gt;</code> : Liste générique (collection d'éléments de même type, taille dynamique, accès par index. Exemple :
                            <pre>
                            <code>
List&lt;int&gt; numbers = new List&lt;int&gt;(); // Déclare une liste d'entiers
numbers.Add(1); // Ajoute un élément à la liste
int firstNumber = numbers[0]; // Accède au premier élément
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>Dictionary&lt;TKey, TValue&gt;</code> : Collection de paires clé-valeur (permet de stocker des éléments associés à une clé unique, accès rapide par clé. Exemple :
                            <pre>
                            <code>
Dictionary&lt;string, int&gt; ages = new Dictionary&lt;string, int&gt;(); // Déclare un dictionnaire avec des chaînes comme clés et des entiers comme valeurs
ages["Alice"] = 30; // Assigne la valeur 30 à la clé "Alice"
int aliceAge = ages["Alice"]; // Accède à la valeur associée à la clé "Alice"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>Queue&lt;T&gt;</code> : File d'attente (collection FIFO - First In, First Out, éléments ajoutés à la fin et retirés du début. Exemple :
                            <pre>
                            <code>
Queue&lt;int&gt; queue = new Queue&lt;int&gt;(); // Déclare une file d'attente d'entiers
queue.Enqueue(1); // Ajoute un élément à la fin de la file
int firstInQueue = queue.Dequeue(); // Retire et retourne l'élément au début de la file
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>Stack&lt;T&gt;</code> : Pile (collection LIFO - Last In, First Out, éléments ajoutés et retirés du sommet. Exemple :
                            <pre>
                            <code>
Stack&lt;int&gt; stack = new Stack&lt;int&gt;(); // Déclare une pile d'entiers
stack.Push(1); // Ajoute un élément au sommet de la pile
int topOfStack = stack.Pop(); // Retire et retourne l'élément au sommet de la pile
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>IEnumerable&lt;T&gt;</code> : Interface pour énumérables (permet l'itération sur une collection, utilisée avec <code>foreach</code>. Exemple :
                            <pre>
                            <code>
IEnumerable&lt;int&gt; numbers = new List&lt;int&gt; { 1, 2, 3 }; // Déclare une collection énumérable d'entiers
foreach (int number in numbers)
{
    Console.WriteLine(number); // Itère sur chaque élément de la collection
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Exceptions et Gestion des erreurs -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSix" aria-expanded="false" aria-controls="collapseSix">
                    6. Exceptions et Gestion des erreurs (Exceptions and Error Handling)
                </button>
            </h2>
            <div id="collapseSix" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <code>try</code>, <code>catch</code>, <code>finally</code> : Gestion des exceptions (permet de gérer les erreurs de manière contrôlée, <code>try</code> encapsule le code susceptible de générer une exception, <code>catch</code> capture et traite l'exception, <code>finally</code> exécute du code après le bloc <code>try</code> et <code>catch</code>, qu'une exception ait été levée ou non. Exemple :
                            <pre>
                            <code>
try
{
    // Code susceptible de générer une exception
}
catch (Exception ex)
{
    // Code pour gérer l'exception
}
finally
{
    // Code qui s'exécute toujours, qu'une exception ait été levée ou non
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>throw</code> : Lever une exception (utilisé pour générer une exception manuellement. Exemple :
                            <pre>
                            <code>
if (someCondition)
{
    throw new InvalidOperationException("Message d'erreur");
}   
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>Exception</code> : Classe de base (classe de base pour toutes les exceptions en C#, fournit des informations sur l'erreur, comme le message d'erreur et la pile d'appels. Exemple :
                            <pre>
                            <code>
try
{
    // Code susceptible de générer une exception
}
catch (Exception ex)
{
    Console.WriteLine(ex.Message); // Affiche le message d'erreur
    Console.WriteLine(ex.StackTrace); // Affiche la pile d'appels
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>NullReferenceException</code> : Exception de référence nulle (levée lorsqu'une tentative est faite pour accéder à un objet via une référence nulle. Exemple :
                            <pre>
                            <code>
object obj = null;
try
{
    int length = obj.ToString().Length; // Lève une NullReferenceException
}
catch (NullReferenceException ex)
{
    Console.WriteLine("Une référence nulle a été rencontrée.");
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <code>ArgumentNullException</code> : Argument nul (levée lorsqu'un argument passé à une méthode est <code>null</code> alors qu'il ne devrait pas l'être. Exemple :
                            <pre>
                            <code>
void SomeMethod(string param)
{
    if (param == null)
    {
        throw new ArgumentNullException(nameof(param), "Le paramètre ne peut pas être nul");
    }
    // Autre code
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire de Serveur Web (Backend)</h1>

    <div class="accordion">
        <!-- Section Serveur -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#serverSection" aria-expanded="false" aria-controls="serverSection">
                    Serveurs Web
                </button>
            </h2>
            <div id="serverSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Apache</strong> : Serveur web open source, très utilisé pour héberger des sites web. Il est connu pour sa flexibilité et sa large adoption. Exemple de configuration :
                            <pre>
                            <code>
&lt;VirtualHost *:80&gt;
ServerAdmin webmaster@dummy-host.example.com
DocumentRoot "/www/docs/dummy-host.example.com"
ServerName dummy-host.example.com
ErrorLog "logs/dummy-host.example.com-error_log"
CustomLog "logs/dummy-host.example.com-access_log" common
&lt;/VirtualHost&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Nginx</strong> : Serveur web performant utilisé pour gérer de grandes quantités de trafic. Il est souvent utilisé comme reverse proxy et load balancer. Exemple de configuration :
                            <pre>
                            <code>
server {
listen 80;
server_name example.com;
location / {
    proxy_pass http://localhost:8080;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>IIS</strong> (Internet Information Services) : Serveur web de Microsoft. Il est intégré à Windows Server et offre une gestion facile des sites web et des applications. Exemple de configuration :
                            <pre>
                            <code>
&lt;configuration&gt;
    &lt;system.webServer&gt;
        &lt;handlers&gt;
            &lt;add name="iisnode" path="app.js" verb="*" modules="iisnode" /&gt;
        &lt;/handlers&gt;
        &lt;rewrite&gt;
            &lt;rules&gt;
                &lt;rule name="DynamicContent" patternSyntax="ECMAScript" stopProcessing="true"&gt;
                    &lt;match url=".*" /&gt;
                    &lt;conditions&gt;
                        &lt;add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" /&gt;
                    &lt;/conditions&gt;
                    &lt;action type="Rewrite" url="app.js" /&gt;
                &lt;/rule&gt;
            &lt;/rules&gt;
        &lt;/rewrite&gt;
    &lt;/system.webServer&gt;
&lt;/configuration&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Reverse Proxy</strong> : Serveur qui redirige les requêtes vers d'autres serveurs backend. Utilisé pour améliorer la sécurité, la performance et la distribution de la charge. Exemple avec Nginx :
                            <pre>
                            <code>
server {
    listen 80;
    server_name example.com;
    location / {
        proxy_pass http://backend_server;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Load Balancer</strong> : Outil distribuant les requêtes entre plusieurs serveurs pour équilibrer la charge. Utilisé pour améliorer la disponibilité et la performance des applications. Exemple avec Nginx :
                            <pre>
                            <code>
upstream backend {
    server backend1.example.com;
    server backend2.example.com;
}
server {
    listen 80;
    server_name example.com;
    location / {
        proxy_pass http://backend;
    }
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section API -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#apiSection" aria-expanded="false" aria-controls="apiSection">
                    API (Application Programming Interface)
                </button>
            </h2>
            <div id="apiSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>REST</strong> : Style d'architecture d'API utilisant les méthodes HTTP (GET, POST, PUT, DELETE). Utilisé pour créer des services web légers et évolutifs. Exemple de requête GET :
                            <pre>
                            <code>
GET /api/users/1 HTTP/1.1
Host: example.com
Accept: application/json
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>SOAP</strong> : Protocole plus structuré pour échanger des données via des services web. Utilisé pour des communications plus formelles et sécurisées. Exemple de requête SOAP :
                            <pre>
                            <code>
&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:web="http://example.com/webservices"&gt;
    &lt;soapenv:Header/&gt;
    &lt;soapenv:Body&gt;
        &lt;web:GetUser&gt;
            &lt;web:UserId&gt;1&lt;/web:UserId&gt;
        &lt;/web:GetUser&gt;
    &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>GraphQL</strong> : Langage de requête pour interroger des APIs, permettant de demander des données précises. Utilisé pour optimiser les requêtes et réduire la surcharge de données. Exemple de requête GraphQL :
                            <pre>
                            <code>
{
    user(id: "1") {
    name
    email
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>JSON</strong> : Format d'échange de données utilisé pour les API REST. Utilisé pour sa simplicité et sa compatibilité avec de nombreux langages. Exemple de données JSON :
                            <pre>
                            <code>
{
    "name": "Alice",
    "age": 30,
    "email": "alice@example.com"
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>XML</strong> : Format de données structuré souvent utilisé avec SOAP. Utilisé pour sa capacité à représenter des données hiérarchiques. Exemple de données XML :
                            <pre>
                            <code>
&lt;user&gt;
    &lt;name&gt;Alice&lt;/name&gt;
    &lt;age&gt;30&lt;/age&gt;
    &lt;email&gt;alice@example.com&lt;/email&gt;
&lt;/user&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>OAuth</strong> : Protocole d'authentification utilisé pour sécuriser les API. Utilisé pour permettre à des applications tierces d'accéder aux ressources d'un utilisateur sans partager ses identifiants. Exemple de flux OAuth :
                            <pre>
                            <code>
1. L'utilisateur se connecte et autorise l'application.
2. L'application reçoit un code d'autorisation.
3. L'application échange le code contre un jeton d'accès.
4. L'application utilise le jeton d'accès pour accéder aux ressources protégées.
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>JWT</strong> (JSON Web Token) : Standard pour créer des jetons d'accès sécurisés pour les API. Utilisé pour transmettre des informations de manière sécurisée entre les parties. Exemple de JWT :
                            <pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Bases de Données -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#dbSection" aria-expanded="false" aria-controls="dbSection">
                    Bases de Données
                </button>
            </h2>
            <div id="dbSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>SQL</strong> : Langage pour interagir avec des bases de données relationnelles (MySQL, PostgreSQL, SQL Server). Utilisé pour gérer et manipuler les données dans des bases de données structurées. Exemple de requête SQL :
                            <pre><code>SELECT * FROM Users WHERE Age &gt; 30;</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>NoSQL</strong> : Type de base de données non relationnelle (MongoDB, Cassandra, Redis). Utilisé pour des données non structurées ou semi-structurées, souvent pour des applications nécessitant une grande scalabilité. Exemple de document MongoDB :
                            <pre>
                            <code>
{
    "name": "Alice",
    "age": 30,
    "email": "alice@example.com"
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ORM</strong> (Object-Relational Mapping) : Outil pour manipuler les données en base via des objets (ex : Entity Framework, Hibernate). Utilisé pour simplifier les interactions avec la base de données en mappant les tables à des classes. Exemple avec Entity Framework :
                            <pre>
                            <code>
public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Age { get; set; }
}
using (var context = new MyDbContext())
{
    var users = context.Users.Where(u => u.Age &gt; 30).ToList();
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>CRUD</strong> : Acronyme pour Create, Read, Update, Delete, les opérations basiques sur une base de données. Utilisé pour définir les opérations fondamentales de manipulation des données. Exemple de requêtes CRUD :
                            <pre>
                            <code>
// Create
INSERT INTO Users (Name, Age) VALUES ('Alice', 30);

// Read
SELECT * FROM Users WHERE Id = 1;

// Update
UPDATE Users SET Age = 31 WHERE Id = 1;

// Delete
DELETE FROM Users WHERE Id = 1;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ACID</strong> : Propriétés des transactions en bases relationnelles (Atomicité, Cohérence, Isolation, Durabilité). Utilisé pour garantir la fiabilité des transactions dans une base de données. Exemple :
                            <pre>
                            <code>
// Atomicité : Toutes les opérations d'une transaction sont exécutées ou aucune ne l'est.
// Cohérence : La base de données passe d'un état valide à un autre état valide.
// Isolation : Les transactions concurrentes n'interfèrent pas entre elles.
// Durabilité : Les résultats d'une transaction sont permanents même en cas de panne.
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Sharding</strong> : Technique de partitionnement des données pour améliorer la performance d'une base. Utilisé pour distribuer les données sur plusieurs serveurs pour équilibrer la charge et améliorer la scalabilité. Exemple :
                            <pre>
                            <code>
// Sharding horizontal : Les lignes d'une table sont réparties sur plusieurs bases de données.
// Sharding vertical : Les colonnes d'une table sont réparties sur plusieurs bases de données.
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Authentification et Sécurité -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#securitySection" aria-expanded="false" aria-controls="securitySection">
                    Authentification et Sécurité
                </button>
            </h2>
            <div id="securitySection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>HTTPS</strong> : Protocole sécurisé pour la communication entre le client et le serveur web. Utilisé pour protéger les données échangées contre les interceptions et les attaques. Exemple d'URL HTTPS :
                            <pre><code>https://example.com</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>SSL/TLS</strong> : Protocole de cryptage utilisé pour sécuriser les communications HTTP. Utilisé pour établir une connexion sécurisée entre le client et le serveur. Exemple de configuration Nginx pour SSL/TLS :
                            <pre>
                            <code>
server {
    listen 443 ssl;
    server_name example.com;
    ssl_certificate /etc/ssl/certs/example.com.crt;
    ssl_certificate_key /etc/ssl/private/example.com.key;
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>OAuth</strong> : Protocole pour l'autorisation d'accès à des ressources sécurisées. Utilisé pour permettre à des applications tierces d'accéder aux ressources d'un utilisateur sans partager ses identifiants. Exemple de flux OAuth :
                            <pre>
                            <code>
1. L'utilisateur se connecte et autorise l'application.
2. L'application reçoit un code d'autorisation.
3. L'application échange le code contre un jeton d'accès.
4. L'application utilise le jeton d'accès pour accéder aux ressources protégées.
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>JWT</strong> : Jetons pour sécuriser l'accès aux API et l'authentification. Utilisé pour transmettre des informations de manière sécurisée entre les parties. Exemple de JWT :
                            <pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Basic Auth</strong> : Méthode d'authentification utilisant des identifiants de base (nom d'utilisateur/mot de passe). Utilisé pour des scénarios simples où la sécurité n'est pas une préoccupation majeure. Exemple d'en-tête HTTP Basic Auth :
                            <pre><code>Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>CSRF</strong> : Cross-Site Request Forgery, attaque de type injection de requêtes. Utilisé pour tromper un utilisateur authentifié en lui faisant exécuter des actions non désirées. Exemple de protection CSRF en ASP.NET :
                            <pre><code>&#64Html.AntiForgeryToken()</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>XSS</strong> : Cross-Site Scripting, attaque visant à injecter du code malveillant dans une page web. Utilisé pour voler des informations sensibles ou manipuler le contenu de la page. Exemple de protection XSS en ASP.NET :
                            <pre><code>&#64Html.Encode(userInput)</code></pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section DevOps et Déploiement -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#devOpsSection" aria-expanded="false" aria-controls="devOpsSection">
                    DevOps et Déploiement
                </button>
            </h2>
            <div id="devOpsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>CI/CD</strong> (Continuous Integration/Continuous Deployment) : Automatisation des processus de build et de déploiement. Utilisé pour améliorer la qualité du code et accélérer les cycles de développement. Exemple d'outil CI/CD : Jenkins, GitHub Actions.
                            <pre>
                            <code>
// Exemple de pipeline CI/CD avec GitHub Actions
name: CI/CD Pipeline

on: [push]

jobs:
    build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up .NET
        uses: actions/setup-dotnet@v1
        with:
        dotnet-version: '5.0.x'
    - name: Build with dotnet
        run: dotnet build --configuration Release
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Docker</strong> : Conteneurisation des applications pour un déploiement standardisé. Utilisé pour isoler les applications et leurs dépendances dans des conteneurs légers. Exemple de fichier Dockerfile :
                            <pre>
                            <code>
# Utilise une image de base .NET
FROM mcr.microsoft.com/dotnet/aspnet:5.0
COPY . /app
WORKDIR /app
EXPOSE 80
ENTRYPOINT ["dotnet", "MyApp.dll"]
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Kubernetes</strong> : Orchestration de conteneurs pour gérer le déploiement et la mise à l'échelle. Utilisé pour automatiser le déploiement, la gestion et la mise à l'échelle des applications conteneurisées. Exemple de fichier de déploiement Kubernetes :
                            <pre>
                            <code>
apiVersion: apps/v1
kind: Deployment
metadata:
    name: myapp-deployment
spec:
    replicas: 3
    selector:
    matchLabels:
        app: myapp
    template:
    metadata:
        labels:
        app: myapp
    spec:
        containers:
        - name: myapp
        image: myapp:latest
        ports:
        - containerPort: 80
                                    </code>
                                </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Ansible</strong> : Outil d'automatisation pour gérer l'infrastructure. Utilisé pour automatiser les tâches de configuration, de gestion et de déploiement des serveurs. Exemple de playbook Ansible :
                            <pre>
                            <code>
- name: Installer et démarrer Apache
    hosts: webservers
    become: yes
    tasks:
    - name: Installer Apache
        apt:
        name: apache2
        state: present
    - name: Démarrer Apache
        service:
        name: apache2
        state: started
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Terraform</strong> : Outil d'infrastructure as code pour créer et gérer l'infrastructure cloud. Utilisé pour définir et provisionner l'infrastructure de manière déclarative. Exemple de configuration Terraform :
                            <pre>
                            <code>
provider "aws" {
    region = "us-west-2"
}

resource "aws_instance" "example" {
    ami           = "ami-0c55b159cbfafe1f0"
    instance_type = "t2.micro"

    tags = {
    Name = "example-instance"
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Load Balancer</strong> : Distribution du trafic entre plusieurs serveurs pour équilibrer la charge. Utilisé pour améliorer la disponibilité et la performance des applications. Exemple de configuration Nginx pour un load balancer :
                            <pre>
                            <code>
http {
    upstream myapp {
        server app1.example.com;
        server app2.example.com;
    }

    server {
        listen 80;
        location / {
            proxy_pass http://myapp;
        }
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Monitoring</strong> : Surveillance des applications et des serveurs pour détecter les anomalies (ex : Prometheus, Grafana). Utilisé pour assurer la disponibilité et la performance des systèmes. Exemple de configuration Prometheus :
                            <pre>
                            <code>
global:
    scrape_interval: 15s

scrape_configs:
    - job_name: 'prometheus'
    static_configs:
        - targets: ['localhost:9090']
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire Microsoft : Controllers, Testing, Models, Enums, Resources</h1>

    <div class="accordion">
        <!-- Section Controllers -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#controllersSection" aria-expanded="false" aria-controls="controllersSection">
                    Controllers
                </button>
            </h2>
            <div id="controllersSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Controller</strong> : Composant qui gère les requêtes HTTP et renvoie les réponses. Utilisé dans ASP.NET MVC et ASP.NET Core. Les contrôleurs contiennent des actions qui sont appelées en réponse à des requêtes HTTP. Exemple de contrôleur :
                            <pre>
                            <code>
public class HomeController : Controller
{
    public IActionResult Index()
    {
        return View();
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ActionResult</strong> : Type de retour d'une méthode d'action dans un controller, qui peut représenter divers résultats (vue, JSON, redirection). Il permet de retourner différents types de réponses HTTP en fonction des besoins de l'application. Exemple d'utilisation d'ActionResult :
                            <pre>
                            <code>
public IActionResult GetUser(int id)
{
    var user = _userService.GetUserById(id);
    if (user == null)
    {
        return NotFound();
    }
    return Ok(user);
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ApiController</strong> : Utilisé pour définir des contrôleurs d'API dans ASP.NET Core. Il simplifie la création de services RESTful en fournissant des fonctionnalités comme la validation automatique des modèles et la gestion des erreurs. Exemple de contrôleur d'API :
                            <pre>
                            <code>
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    [HttpGet("{id}")]
    public IActionResult GetUser(int id)
    {
        var user = _userService.GetUserById(id);
        if (user == null)
        {
            return NotFound();
        }
        return Ok(user);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Route</strong> : Définition du chemin de la requête HTTP à associer à un controller/action. Les routes peuvent être définies de manière conventionnelle ou via des attributs pour spécifier comment les URL sont mappées aux actions des contrôleurs. Exemple de route avec attribut :
                            <pre>
                            <code>
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    [HttpGet("{id}")]
    public IActionResult GetProduct(int id)
    {
        var product = _productService.GetProductById(id);
        if (product == null)
        {
            return NotFound();
        }
        return Ok(product);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>HttpGet, HttpPost, HttpPut, HttpDelete</strong> : Attributs pour spécifier le type de requête HTTP auquel une action doit répondre. <code>HttpGet</code> est utilisé pour les requêtes de lecture, <code>HttpPost</code> pour les créations, <code>HttpPut</code> pour les mises à jour, et <code>HttpDelete</code> pour les suppressions. Exemple d'utilisation des attributs HTTP :
                            <pre>
                            <code>
[HttpGet("{id}")]
public IActionResult GetItem(int id)
{
    var item = _itemService.GetItemById(id);
    if (item == null)
    {
        return NotFound();
    }
    return Ok(item);
}

[HttpPost]
public IActionResult CreateItem([FromBody] Item item)
{
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }
    _itemService.AddItem(item);
    return CreatedAtAction(nameof(GetItem), new { id = item.Id }, item);
}

[HttpPut("{id}")]
public IActionResult UpdateItem(int id, [FromBody] Item item)
{
    if (id != item.Id || !ModelState.IsValid)
    {
        return BadRequest();
    }
    _itemService.UpdateItem(item);
    return NoContent();
}

[HttpDelete("{id}")]
public IActionResult DeleteItem(int id)
{
    var item = _itemService.GetItemById(id);
    if (item == null)
    {
        return NotFound();
    }
    _itemService.DeleteItem(id);
    return NoContent();
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Model Binding</strong> : Processus d'association des données de la requête HTTP aux paramètres d'une action. Il permet de convertir automatiquement les données de la requête (comme les formulaires ou les JSON) en objets C# utilisables dans les actions des contrôleurs. Exemple de model binding :
                            <pre>
                            <code>
public IActionResult CreateUser([FromBody] User user)
{
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }
    _userService.AddUser(user);
    return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Testing -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#testingSection" aria-expanded="false" aria-controls="testingSection">
                    Testing
                </button>
            </h2>
            <div id="testingSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Unit Test</strong> : Test de la plus petite unité fonctionnelle du code, généralement une méthode ou une classe. Les tests unitaires sont utilisés pour vérifier que chaque unité de code fonctionne comme prévu de manière isolée. Exemple de test unitaire avec xUnit :
                            <pre>
                            <code>
public class CalculatorTests
{
    [Fact]
    public void Add_ReturnsSum()
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        var result = calculator.Add(2, 3);

        // Assert
        Assert.Equal(5, result);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Integration Test</strong> : Test qui vérifie l'intégration entre plusieurs composants ou services. Les tests d'intégration s'assurent que les différents modules de l'application fonctionnent ensemble correctement. Exemple de test d'intégration avec xUnit et ASP.NET Core :
                            <pre>
                            <code>
public class UsersControllerTests : IClassFixture&lt;WebApplicationFactory&lt;Startup&gt;&gt;
{
    private readonly HttpClient _client;

    public UsersControllerTests(WebApplicationFactory&lt;Startup&gt; factory)
    {
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task GetUser_ReturnsUser()
    {
        // Act
        var response = await _client.GetAsync("/api/users/1");

        // Assert
        response.EnsureSuccessStatusCode();
        var user = await response.Content.ReadAsAsync&lt;User&gt;();
        Assert.Equal(1, user.Id);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>MSTest</strong> : Framework de tests pour les applications .NET. MSTest est l'un des frameworks de test intégrés dans Visual Studio, permettant d'écrire et d'exécuter des tests unitaires et d'intégration. Exemple de test unitaire avec MSTest :
                            <pre>
                            <code>
[TestClass]
public class CalculatorTests
{
    [TestMethod]
    public void Add_ReturnsSum()
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        var result = calculator.Add(2, 3);

        // Assert
        Assert.AreEqual(5, result);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>xUnit</strong> : Framework de tests populaire pour .NET, utilisé pour les tests unitaires. xUnit est connu pour sa simplicité et sa flexibilité, et il est souvent utilisé dans les projets open-source et professionnels. Exemple de test unitaire avec xUnit :
                            <pre>
                            <code>
public class CalculatorTests
{
    [Fact]
    public void Add_ReturnsSum()
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        var result = calculator.Add(2, 3);

        // Assert
        Assert.Equal(5, result);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Mocking</strong> : Technique de simulation d'objets ou de services dans les tests unitaires. Le mocking permet de créer des objets factices qui imitent le comportement des objets réels, facilitant ainsi le test des composants en isolation. Exemple de mocking avec Moq :
                            <pre>
                            <code>
var mockRepository = new Mock&lt;IUserRepository&gt;();
mockRepository.Setup(repo => repo.GetUserById(1)).Returns(new User { Id = 1, Name = "Alice" });

var userService = new UserService(mockRepository.Object);
var user = userService.GetUserById(1);

Assert.Equal("Alice", user.Name);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Arrange-Act-Assert (AAA)</strong> : Patron de test standard pour structurer les tests (préparer, exécuter, vérifier). <strong>Arrange</strong> : Préparer les conditions initiales et les objets nécessaires. <strong>Act</strong> : Exécuter l'action ou la méthode à tester. <strong>Assert</strong> : Vérifier que le résultat obtenu correspond au résultat attendu. Exemple de test structuré en AAA :
                            <pre>
                            <code>
public class CalculatorTests
{
    [Fact]
    public void Add_ReturnsSum()
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        var result = calculator.Add(2, 3);

        // Assert
        Assert.Equal(5, result);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>TestFixture</strong> : Classe contenant des tests dans un framework de test. Une TestFixture regroupe plusieurs tests qui partagent une configuration commune, facilitant ainsi l'organisation et l'exécution des tests. Exemple de TestFixture avec NUnit :
                            <pre>
                            <code>
[TestFixture]
public class CalculatorTests
{
    private Calculator _calculator;

    [SetUp]
    public void SetUp()
    {
        _calculator = new Calculator();
    }

    [Test]
    public void Add_ReturnsSum()
    {
        var result = _calculator.Add(2, 3);
        Assert.AreEqual(5, result);
    }
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Models -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#modelsSection" aria-expanded="false" aria-controls="modelsSection">
                    Models
                </button>
            </h2>
            <div id="modelsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Model</strong> : Classe représentant les données ou les objets métiers dans une application. Les modèles sont utilisés pour transférer des données entre les différentes couches de l'application, comme la couche de présentation et la couche de données. Exemple de modèle :
                            <pre>
                            <code>
public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ViewModel</strong> : Objet qui regroupe les données nécessaires pour être affichées dans une vue. Le ViewModel est utilisé pour préparer et formater les données avant de les envoyer à la vue, facilitant ainsi la liaison des données et la logique de présentation. Exemple de ViewModel :
                            <pre>
                            <code>
public class UserViewModel
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public string DisplayName => $"{Name} ({Email})";
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Data Annotations</strong> : Attributs utilisés pour valider les données dans les modèles. Par exemple, <code>[Required]</code> assure qu'une propriété n'est pas nulle, <code>[StringLength]</code> définit la longueur maximale d'une chaîne, et <code>[Range]</code> spécifie une plage de valeurs acceptables. Ces annotations aident à garantir l'intégrité des données avant qu'elles ne soient enregistrées dans la base de données. Exemple d'annotations de données :
                            <pre>
                            <code>
public class User
{
    [Required]
    public string Name { get; set; }

    [Required, EmailAddress]
    public string Email { get; set; }

    [Range(18, 99)]
    public int Age { get; set; }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Entity Framework</strong> : ORM (Object-Relational Mapping) pour interagir avec une base de données en utilisant des modèles. Entity Framework permet de travailler avec des bases de données en utilisant des objets C# plutôt que des requêtes SQL, facilitant ainsi le développement et la maintenance des applications. Exemple d'utilisation d'Entity Framework :
                            <pre>
                            <code>
public class ApplicationDbContext : DbContext
{
    public DbSet&lt;User&gt; Users { get; set; }
}

public class UserService
{
    private readonly ApplicationDbContext _context;

    public UserService(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task&lt;List&lt;User&gt;&gt; GetUsersAsync()
    {
        return await _context.Users.ToListAsync();
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Scaffold</strong> : Technique de génération automatique de code pour les modèles, vues et contrôleurs. Le scaffolding permet de créer rapidement des opérations CRUD (Create, Read, Update, Delete) en générant le code nécessaire pour interagir avec la base de données et afficher les données dans l'interface utilisateur. Exemple de commande de scaffolding :
                            <pre><code>dotnet ef dbcontext scaffold "Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;" Microsoft.EntityFrameworkCore.SqlServer -o Models</code></pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Enums -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#enumsSection" aria-expanded="false" aria-controls="enumsSection">
                    Enums (Enumerations)
                </button>
            </h2>
            <div id="enumsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Enum</strong> : Type spécial qui définit un ensemble de constantes nommées. Les énumérations sont utilisées pour représenter un ensemble de valeurs possibles pour une variable. Exemple :
                            <pre>
                            <code>
public enum Days
{
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday
}
                                </code>
                            </pre>
                            Cela permet de rendre le code plus lisible et de réduire les erreurs en limitant les valeurs possibles.
                        </li>
                        <li class="list-group-item">
                            <strong>Flags Attribute</strong> : Attribut qui permet à un enum d'être traité comme un ensemble de bits (valeurs combinées). Cet attribut est utilisé pour créer des énumérations qui peuvent être combinées avec des opérations bit à bit. Exemple :
                            <pre>
                            <code>
[Flags]
public enum FileAccess
{
    Read = 1,
    Write = 2,
    Execute = 4
}
                                </code>
                            </pre>
                            Cela permet de combiner les valeurs comme <code>FileAccess.Read | FileAccess.Write</code>.
                        </li>
                        <li class="list-group-item">
                            <strong>Enum.Parse()</strong> : Méthode permettant de convertir une chaîne en valeur d'énumération. Cette méthode est utile pour convertir des valeurs de chaîne en types d'énumération. Exemple :
                            <pre><code>Days day = (Days)Enum.Parse(typeof(Days), "Sunday");</code></pre>
                            Cela permet de convertir la chaîne "Sunday" en la valeur d'énumération correspondante.
                        </li>
                        <li class="list-group-item">
                            <strong>Enum.GetValues()</strong> : Méthode pour obtenir toutes les valeurs possibles d'un enum. Cette méthode retourne un tableau de toutes les valeurs définies dans une énumération. Exemple :
                            <pre><code>Days[] days = (Days[])Enum.GetValues(typeof(Days));</code></pre>
                            Cela permet de parcourir toutes les valeurs possibles de l'énumération <code>Days</code>.
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Resources -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#resourcesSection" aria-expanded="false" aria-controls="resourcesSection">
                    Resources
                </button>
            </h2>
            <div id="resourcesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Resource File (.resx)</strong> : Fichier XML utilisé pour stocker des chaînes de texte, images et autres objets pour la localisation. Les fichiers .resx permettent de séparer les ressources de l'application du code, facilitant ainsi la traduction et la gestion des ressources. Exemple :
                            <pre>
                            <code>
// strings.fr.resx
&lt;root&gt;
    &lt;data name="Hello" xml:space="preserve"&gt;
    &lt;value&gt;Bonjour&lt;/value&gt;
    &lt;/data&gt;
&lt;/root&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Globalization</strong> : Concept d'internationalisation et de localisation d'une application pour différents marchés ou langues. La globalisation implique la conception et le développement d'une application de manière à ce qu'elle puisse être facilement adaptée à différentes cultures et langues sans nécessiter de modifications majeures du code. Exemple :
                            <pre>
                            <code>
public void ConfigureServices(IServiceCollection services)
{
    services.AddLocalization(options => options.ResourcesPath = "Resources");
    services.Configure&lt;RequestLocalizationOptions&gt;(options =>
    {
        var supportedCultures = new[] { "en-US", "fr-FR" };
        options.SetDefaultCulture(supportedCultures[0])
                .AddSupportedCultures(supportedCultures)
                .AddSupportedUICultures(supportedCultures);
    });
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Localization</strong> : Adaptation d'une application aux spécificités culturelles d'une région ou d'un pays. La localisation inclut la traduction des chaînes de texte, l'adaptation des formats de date et de monnaie, et la gestion des particularités culturelles. Exemple :
                            <pre>
                            <code>
&#64;inject IStringLocalizer&lt;Vocabulary_fr&gt; Localizer

&lt;p&gt;&#64;Localizer["Hello"]&lt;/p&gt;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ResourceManager</strong> : Classe utilisée pour charger les ressources d'un fichier .resx. Le <code>ResourceManager</code> permet de récupérer les chaînes de texte et autres ressources localisées en fonction de la culture actuelle de l'application. Exemple :
                            <pre>
                            <code>
var resourceManager = new ResourceManager("MyApp.Resources.strings", typeof(Program).Assembly);
string hello = resourceManager.GetString("Hello", new CultureInfo("fr-FR"));
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Satellite Assemblies</strong> : Assemblies contenant des ressources pour une culture spécifique. Les assemblies satellites sont utilisés pour déployer les ressources localisées séparément du code principal de l'application, permettant ainsi de gérer les traductions et les mises à jour des ressources de manière indépendante. Exemple :
                            <pre>
                            <code>
// Structure des fichiers
// MyApp.dll
// fr-FR/MyApp.resources.dll
// en-US/MyApp.resources.dll
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>CultureInfo</strong> : Classe utilisée pour définir des informations culturelles, telles que les formats de date, monnaie, et langues. La classe <code>CultureInfo</code> permet de spécifier la culture actuelle de l'application et d'accéder aux informations culturelles associées. Exemple :
                            <pre>
                            <code>
CultureInfo.CurrentCulture = new CultureInfo("fr-FR");
CultureInfo.CurrentUICulture = new CultureInfo("fr-FR");
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire Web API</h1>

    <div class="accordion">
        <!-- Section Concepts de Base -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#basicConceptsSection" aria-expanded="false" aria-controls="basicConceptsSection">
                    Concepts de Base
                </button>
            </h2>
            <div id="basicConceptsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>API</strong> : Interface de programmation d'application permettant à deux systèmes logiciels de communiquer entre eux. Une API (Application Programming Interface) définit un ensemble de règles et de conventions pour l'interaction entre des composants logiciels. Les API sont utilisées pour permettre l'intégration de services et de fonctionnalités entre différentes applications. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'appel à une API REST en utilisant HttpClient en C#
var client = new HttpClient();
var response = await client.GetAsync("https://api.example.com/data");
var data = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Endpoint</strong> : URL ou URI d'une ressource spécifique dans une API. Un endpoint est une adresse unique où une API peut être accédée par des requêtes HTTP. Chaque endpoint correspond à une fonction ou une ressource spécifique de l'API. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'appel à un endpoint spécifique d'une API REST
var client = new HttpClient();
var response = await client.GetAsync("https://api.example.com/users/1");
var user = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>REST (Representational State Transfer)</strong> : Style architectural basé sur des ressources accessibles via des méthodes HTTP standard (GET, POST, PUT, DELETE). REST est un style d'architecture pour les services web qui utilise les méthodes HTTP pour effectuer des opérations sur les ressources identifiées par des URI. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de méthodes HTTP dans une API REST
var client = new HttpClient();

// GET - Récupérer une ressource
var getResponse = await client.GetAsync("https://api.example.com/items");

// POST - Créer une nouvelle ressource
var newItem = new StringContent("{\"name\":\"NewItem\"}", Encoding.UTF8, "application/json");
var postResponse = await client.PostAsync("https://api.example.com/items", newItem);

// PUT - Mettre à jour une ressource existante
var updatedItem = new StringContent("{\"name\":\"UpdatedItem\"}", Encoding.UTF8, "application/json");
var putResponse = await client.PutAsync("https://api.example.com/items/1", updatedItem);

// DELETE - Supprimer une ressource
var deleteResponse = await client.DeleteAsync("https://api.example.com/items/1");
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>HTTP</strong> : Protocole utilisé par les API Web pour la communication entre client et serveur. HTTP (HyperText Transfer Protocol) est le protocole de communication standard pour les échanges de données sur le web. Il définit des méthodes comme GET, POST, PUT, DELETE pour interagir avec les ressources. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de HttpClient pour effectuer une requête HTTP GET
var client = new HttpClient();
var response = await client.GetAsync("https://api.example.com/data");
var data = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Stateless</strong> : Principe selon lequel chaque requête envoyée à une API doit contenir toute l'information nécessaire pour être traitée sans conserver d'état entre les requêtes. Les API REST sont conçues pour être stateless, ce qui signifie que le serveur ne conserve aucune information sur l'état des clients entre les requêtes. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de requête stateless à une API REST
var client = new HttpClient();
var request = new HttpRequestMessage(HttpMethod.Get, "https://api.example.com/data");
request.Headers.Add("Authorization", "Bearer token");
var response = await client.SendAsync(request);
var data = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Méthodes HTTP -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#httpMethodsSection" aria-expanded="false" aria-controls="httpMethodsSection">
                    Méthodes HTTP
                </button>
            </h2>
            <div id="httpMethodsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>GET</strong> : Utilisé pour récupérer des données ou des ressources depuis un serveur. La méthode <code>GET</code> est l'une des méthodes HTTP les plus couramment utilisées pour demander des données à un serveur. Elle est utilisée pour récupérer des informations sans modifier l'état du serveur. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de la méthode GET avec HttpClient en C#
var client = new HttpClient();
var response = await client.GetAsync("https://api.example.com/data");
var data = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>POST</strong> : Utilisé pour envoyer des données au serveur et créer une nouvelle ressource. La méthode <code>POST</code> est utilisée pour soumettre des données au serveur, souvent pour créer une nouvelle ressource. Les données sont généralement envoyées dans le corps de la requête. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de la méthode POST avec HttpClient en C#
var client = new HttpClient();
var content = new StringContent("{\"name\":\"NewItem\"}", Encoding.UTF8, "application/json");
var response = await client.PostAsync("https://api.example.com/items", content);
var result = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>PUT</strong> : Utilisé pour mettre à jour une ressource existante sur le serveur. La méthode <code>PUT</code> est utilisée pour mettre à jour une ressource existante en envoyant les données mises à jour dans le corps de la requête. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de la méthode PUT avec HttpClient en C#
var client = new HttpClient();
var content = new StringContent("{\"name\":\"UpdatedItem\"}", Encoding.UTF8, "application/json");
var response = await client.PutAsync("https://api.example.com/items/1", content);
var result = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>DELETE</strong> : Utilisé pour supprimer une ressource existante sur le serveur. La méthode <code>DELETE</code> est utilisée pour supprimer une ressource spécifiée par l'URI. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de la méthode DELETE avec HttpClient en C#
var client = new HttpClient();
var response = await client.DeleteAsync("https://api.example.com/items/1");
var result = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>PATCH</strong> : Utilisé pour appliquer des modifications partielles à une ressource. La méthode <code>PATCH</code> est utilisée pour appliquer des modifications partielles à une ressource existante. Contrairement à <code>PUT</code>, <code>PATCH</code> ne nécessite pas de fournir une représentation complète de la ressource. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de la méthode PATCH avec HttpClient en C#
var client = new HttpClient();
var content = new StringContent("{\"name\":\"PartiallyUpdatedItem\"}", Encoding.UTF8, "application/json");
var response = await client.PatchAsync("https://api.example.com/items/1", content);
var result = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>HEAD</strong> : Similaire à GET, mais ne renvoie que les en-têtes HTTP sans le corps de la réponse. La méthode <code>HEAD</code> est utilisée pour obtenir les en-têtes de réponse d'une ressource sans récupérer le corps de la réponse. Elle est souvent utilisée pour vérifier l'existence d'une ressource ou pour obtenir des métadonnées. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de la méthode HEAD avec HttpClient en C#
var client = new HttpClient();
var response = await client.SendAsync(new HttpRequestMessage(HttpMethod.Head, "https://api.example.com/data"));
var headers = response.Headers;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>OPTIONS</strong> : Demande au serveur de renvoyer les méthodes HTTP autorisées pour une ressource donnée. La méthode <code>OPTIONS</code> est utilisée pour interroger le serveur sur les méthodes HTTP prises en charge pour une ressource spécifique. Elle est souvent utilisée pour vérifier les capacités du serveur avant de faire une requête réelle. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de la méthode OPTIONS avec HttpClient en C#
var client = new HttpClient();
var response = await client.SendAsync(new HttpRequestMessage(HttpMethod.Options, "https://api.example.com/data"));
var allowedMethods = response.Content.Headers.Allow;
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Codes de Réponse HTTP -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#httpStatusCodesSection" aria-expanded="false" aria-controls="httpStatusCodesSection">
                    Codes de Réponse HTTP
                </button>
            </h2>
            <div id="httpStatusCodesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>200 OK</strong> : La requête a réussi, et la réponse contient les données demandées. Ce code de statut HTTP indique que la requête a été traitée avec succès par le serveur et que les informations demandées sont renvoyées dans le corps de la réponse. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de gestion d'une réponse 200 OK avec HttpClient en C#
var client = new HttpClient();
var response = await client.GetAsync("https://api.example.com/data");
if (response.StatusCode == HttpStatusCode.OK)
{
    var data = await response.Content.ReadAsStringAsync();
    Console.WriteLine("Données reçues : " + data);
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>201 Created</strong> : La ressource a été créée avec succès après un POST. Ce code de statut HTTP indique que la requête POST a été traitée avec succès et qu'une nouvelle ressource a été créée. L'URI de la nouvelle ressource est généralement renvoyée dans l'en-tête Location de la réponse. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de gestion d'une réponse 201 Created avec HttpClient en C#
var client = new HttpClient();
var content = new StringContent("{\"name\":\"NewItem\"}", Encoding.UTF8, "application/json");
var response = await client.PostAsync("https://api.example.com/items", content);
if (response.StatusCode == HttpStatusCode.Created)
{
    var location = response.Headers.Location;
    Console.WriteLine("Nouvelle ressource créée à : " + location);
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>204 No Content</strong> : La requête a réussi, mais il n'y a pas de contenu à renvoyer (utilisé après une mise à jour ou suppression). Ce code de statut HTTP indique que la requête a été traitée avec succès, mais que le serveur ne renvoie aucun contenu dans la réponse. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de gestion d'une réponse 204 No Content avec HttpClient en C#
var client = new HttpClient();
var response = await client.DeleteAsync("https://api.example.com/items/1");
if (response.StatusCode == HttpStatusCode.NoContent)
{
    Console.WriteLine("Ressource supprimée avec succès.");
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>400 Bad Request</strong> : La requête est mal formulée ou contient des erreurs de syntaxe. Ce code de statut HTTP indique que le serveur ne peut pas traiter la requête en raison d'une erreur du client, telle qu'une syntaxe incorrecte ou des paramètres invalides. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de gestion d'une réponse 400 Bad Request avec HttpClient en C#
var client = new HttpClient();
var response = await client.GetAsync("https://api.example.com/invalid-request");
if (response.StatusCode == HttpStatusCode.BadRequest)
{
    var error = await response.Content.ReadAsStringAsync();
    Console.WriteLine("Erreur de requête : " + error);
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>401 Unauthorized</strong> : La requête nécessite une authentification utilisateur ou un jeton d'accès valide. Ce code de statut HTTP indique que l'authentification est requise pour accéder à la ressource demandée. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de gestion d'une réponse 401 Unauthorized avec HttpClient en C#
var client = new HttpClient();
var response = await client.GetAsync("https://api.example.com/protected-resource");
if (response.StatusCode == HttpStatusCode.Unauthorized)
{
    Console.WriteLine("Authentification requise pour accéder à cette ressource.");
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>403 Forbidden</strong> : La requête est légale, mais le serveur refuse d'exécuter l'action. Ce code de statut HTTP indique que le serveur comprend la requête, mais refuse de l'exécuter. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de gestion d'une réponse 403 Forbidden avec HttpClient en C#
var client = new HttpClient();
var response = await client.GetAsync("https://api.example.com/forbidden-resource");
if (response.StatusCode == HttpStatusCode.Forbidden)
{
    Console.WriteLine("Accès refusé à cette ressource.");
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>404 Not Found</strong> : La ressource demandée n'a pas été trouvée sur le serveur. Ce code de statut HTTP indique que le serveur ne trouve pas la ressource demandée. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de gestion d'une réponse 404 Not Found avec HttpClient en C#
var client = new HttpClient();
var response = await client.GetAsync("https://api.example.com/nonexistent-resource");
if (response.StatusCode == HttpStatusCode.NotFound)
{
    Console.WriteLine("Ressource non trouvée.");
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>500 Internal Server Error</strong> : Erreur générique lorsqu'une défaillance côté serveur empêche le traitement de la requête. Ce code de statut HTTP indique qu'une erreur interne du serveur a empêché le traitement de la requête. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de gestion d'une réponse 500 Internal Server Error avec HttpClient en C#
var client = new HttpClient();
var response = await client.GetAsync("https://api.example.com/server-error");
if (response.StatusCode == HttpStatusCode.InternalServerError)
{
    Console.WriteLine("Erreur interne du serveur.");
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Authentification et Autorisation -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#authSection" aria-expanded="false" aria-controls="authSection">
                    Authentification et Autorisation
                </button>
            </h2>
            <div id="authSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>API Key</strong> : Clé secrète générée pour permettre l'accès à une API. Transmise dans l'en-tête ou dans la requête pour authentifier l'utilisateur. Les API Keys sont souvent utilisées pour suivre et contrôler l'utilisation de l'API, ainsi que pour authentifier les requêtes. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation d'une API Key avec HttpClient en C#
var client = new HttpClient();
client.DefaultRequestHeaders.Add("x-api-key", "votre_api_key");
var response = await client.GetAsync("https://api.example.com/data");
var data = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>OAuth</strong> : Protocole standard pour autoriser des applications tierces à accéder à une API en utilisant des jetons d'accès sécurisés. OAuth permet aux utilisateurs de donner à des applications tierces un accès limité à leurs ressources sans partager leurs identifiants. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation d'OAuth pour obtenir un jeton d'accès
var client = new HttpClient();
var tokenResponse = await client.PostAsync("https://auth.example.com/token", new FormUrlEncodedContent(new[]
{
    new KeyValuePair&lt;string, string&gt;("grant_type", "client_credentials"),
    new KeyValuePair&lt;string, string&gt;("client_id", "votre_client_id"),
    new KeyValuePair&lt;string, string&gt;("client_secret", "votre_client_secret")
}));
var token = await tokenResponse.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Bearer Token</strong> : Type de jeton d'authentification transmis dans l'en-tête HTTP <code>Authorization</code>. Les Bearer Tokens sont souvent utilisés avec OAuth pour accéder aux ressources protégées. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation d'un Bearer Token avec HttpClient en C#
var client = new HttpClient();
client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", "votre_bearer_token");
var response = await client.GetAsync("https://api.example.com/protected-resource");
var data = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>JWT (JSON Web Token)</strong> : Jeton encodé qui transporte les informations de session entre le client et le serveur pour authentifier les utilisateurs. Les JWT sont souvent utilisés pour l'authentification et l'autorisation dans les applications web. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de génération et d'utilisation d'un JWT en C#
var tokenHandler = new JwtSecurityTokenHandler();
var key = Encoding.ASCII.GetBytes("votre_cle_secrete");
var tokenDescriptor = new SecurityTokenDescriptor
{
    Subject = new ClaimsIdentity(new[] { new Claim("id", "user_id") }),
    Expires = DateTime.UtcNow.AddHours(1),
    SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
};
var token = tokenHandler.CreateToken(tokenDescriptor);
var jwtToken = tokenHandler.WriteToken(token);

// Utilisation du JWT avec HttpClient
var client = new HttpClient();
client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", jwtToken);
var response = await client.GetAsync("https://api.example.com/protected-resource");
var data = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Basic Auth</strong> : Méthode d'authentification où le client envoie un nom d'utilisateur et un mot de passe encodés en Base64 dans l'en-tête HTTP. Basic Auth est simple à implémenter mais moins sécurisé que d'autres méthodes d'authentification. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de Basic Auth avec HttpClient en C#
var client = new HttpClient();
var byteArray = Encoding.ASCII.GetBytes("username:password");
client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", Convert.ToBase64String(byteArray));
var response = await client.GetAsync("https://api.example.com/protected-resource");
var data = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Formats de Données -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#dataFormatsSection" aria-expanded="false" aria-controls="dataFormatsSection">
                    Formats de Données
                </button>
            </h2>
            <div id="dataFormatsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>JSON (JavaScript Object Notation)</strong> : Format de données léger et lisible utilisé pour échanger des données entre le client et le serveur. JSON est souvent utilisé dans les API web pour envoyer et recevoir des données structurées. Il est facile à lire et à écrire pour les humains, et facile à analyser et à générer pour les machines. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de sérialisation et désérialisation JSON en C#
using System.Text.Json;

// Sérialisation d'un objet en JSON
var person = new { Name = "John", Age = 30 };
string jsonString = JsonSerializer.Serialize(person);

// Désérialisation d'une chaîne JSON en objet
var deserializedPerson = JsonSerializer.Deserialize&lt;Person&gt;(jsonString);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>XML (Extensible Markup Language)</strong> : Format de données extensible utilisé pour structurer et transporter des informations. Il est souvent utilisé comme alternative à JSON. XML est plus verbeux que JSON, mais il est également plus flexible et peut être utilisé pour représenter des données hiérarchiques complexes. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de sérialisation et désérialisation XML en C#
using System.Xml.Serialization;
using System.IO;

// Sérialisation d'un objet en XML
var person = new Person { Name = "John", Age = 30 };
var serializer = new XmlSerializer(typeof(Person));
using (var writer = new StringWriter())
{
    serializer.Serialize(writer, person);
    string xmlString = writer.ToString();
}

// Désérialisation d'une chaîne XML en objet
using (var reader = new StringReader(xmlString))
{
    var deserializedPerson = (Person)serializer.Deserialize(reader);
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Form Data</strong> : Format utilisé pour envoyer des données dans le corps d'une requête POST via des formulaires HTML. Les données de formulaire sont encodées en tant que paires clé-valeur et peuvent inclure des fichiers. Ce format est couramment utilisé pour soumettre des formulaires web. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'envoi de données de formulaire avec HttpClient en C#
var client = new HttpClient();
var formData = new MultipartFormDataContent();
formData.Add(new StringContent("John"), "name");
formData.Add(new StringContent("30"), "age");
var response = await client.PostAsync("https://api.example.com/submit", formData);
var responseString = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Multipart</strong> : Format de données utilisé pour envoyer des fichiers et des données binaires dans une requête HTTP. Le format multipart est souvent utilisé pour les téléchargements de fichiers, car il permet d'envoyer plusieurs parties de données dans une seule requête. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'envoi de données multipart avec HttpClient en C#
var client = new HttpClient();
var multipartContent = new MultipartFormDataContent();
multipartContent.Add(new ByteArrayContent(fileBytes), "file", "filename.txt");
var response = await client.PostAsync("https://api.example.com/upload", multipartContent);
var responseString = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>URLEncoded</strong> : Format dans lequel les données sont encodées dans l'URL d'une requête HTTP (souvent utilisé dans les requêtes GET et POST simples). Les données sont encodées en paires clé-valeur et séparées par des esperluettes (&). Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'envoi de données URL-encoded avec HttpClient en C#
var client = new HttpClient();
var content = new FormUrlEncodedContent(new[]
{
    new KeyValuePair&lt;string, string&gt;("name", "John"),
    new KeyValuePair&lt;string, string&gt;("age", "30")
});
var response = await client.PostAsync("https://api.example.com/submit", content);
var responseString = await response.Content.ReadAsStringAsync();
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Sécurité des API -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#securitySection" aria-expanded="false" aria-controls="securitySection">
                    Sécurité des API
                </button>
            </h2>
            <div id="securitySection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>CORS (Cross-Origin Resource Sharing)</strong> : Mécanisme de sécurité qui permet ou restreint les requêtes HTTP entre des domaines différents (cross-origin). CORS est utilisé pour contrôler quelles ressources peuvent être demandées par des scripts exécutés dans le navigateur sur un domaine différent. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de configuration CORS dans un projet ASP.NET Core
public void ConfigureServices(IServiceCollection services)
{
    services.AddCors(options =>
    {
        options.AddPolicy("AllowSpecificOrigin",
            builder => builder.WithOrigins("https://example.com")
                                .AllowAnyHeader()
                                .AllowAnyMethod());
    });
}

public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseCors("AllowSpecificOrigin");
    app.UseMvc();
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>SSL/TLS</strong> : Protocoles utilisés pour sécuriser la communication entre le client et le serveur via HTTPS. SSL (Secure Sockets Layer) et TLS (Transport Layer Security) chiffrent les données échangées pour garantir la confidentialité et l'intégrité des informations. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de configuration HTTPS dans un projet ASP.NET Core
public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup&lt;Startup&gt;()
                            .UseUrls("https://localhost:5001");
            });
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Rate Limiting</strong> : Stratégie qui limite le nombre de requêtes qu'un client peut faire à une API dans un laps de temps donné, pour prévenir les abus. Le rate limiting est souvent utilisé pour protéger les API contre les attaques par déni de service (DoS) et pour garantir une répartition équitable des ressources. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de configuration de rate limiting avec ASP.NET Core
public void ConfigureServices(IServiceCollection services)
{
    services.AddRateLimiter(options =>
    {
        options.GlobalLimiter = RateLimitPartition.GetFixedWindowLimiter(
            partitionKey: "global",
            factory: partition => new FixedWindowRateLimiterOptions
            {
                PermitLimit = 100,
                Window = TimeSpan.FromMinutes(1)
            });
    });
}

public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseRateLimiter();
    app.UseMvc();
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>IP Whitelisting</strong> : Restriction de l'accès à une API uniquement à une liste spécifique d'adresses IP. L'IP whitelisting est utilisé pour renforcer la sécurité en limitant l'accès aux ressources sensibles uniquement aux adresses IP approuvées. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de configuration d'IP whitelisting dans un projet ASP.NET Core
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.Use(async (context, next) =>
    {
        var allowedIps = new[] { "192.168.1.1", "192.168.1.2" };
        var remoteIp = context.Connection.RemoteIpAddress?.ToString();

        if (!allowedIps.Contains(remoteIp))
        {
            context.Response.StatusCode = StatusCodes.Status403Forbidden;
            await context.Response.WriteAsync("Forbidden");
            return;
        }

        await next();
    });

    app.UseMvc();
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>HMAC (Hash-Based Message Authentication Code)</strong> : Méthode d'authentification et d'intégrité des messages via un hash cryptographique et une clé secrète. HMAC est utilisé pour vérifier l'intégrité et l'authenticité des messages échangés entre le client et le serveur. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de génération d'un HMAC en C#
using System.Security.Cryptography;
using System.Text;

public string GenerateHmac(string message, string secretKey)
{
    var key = Encoding.UTF8.GetBytes(secretKey);
    using (var hmac = new HMACSHA256(key))
    {
        var messageBytes = Encoding.UTF8.GetBytes(message);
        var hash = hmac.ComputeHash(messageBytes);
        return Convert.ToBase64String(hash);
    }
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire xUnit</h1>

    <div class="accordion">
        <!-- Section Concepts de Base xUnit -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#xunitBasicsSection" aria-expanded="false" aria-controls="xunitBasicsSection">
                    Concepts de Base de xUnit
                </button>
            </h2>
            <div id="xunitBasicsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>[Fact]</strong> : Attribut indiquant qu'une méthode est un test qui ne prend aucun paramètre. Utilisé dans le framework de test xUnit, il marque une méthode comme un test unitaire standard. Les méthodes marquées avec <code>[Fact]</code> sont exécutées par le moteur de test sans nécessiter de données d'entrée spécifiques. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de test unitaire avec [Fact]
public class CalculatorTests
{
    [Fact]
    public void Add_ReturnsCorrectSum()
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        var result = calculator.Add(2, 3);

        // Assert
        Assert.Equal(5, result);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>[Theory]</strong> : Attribut utilisé pour marquer une méthode de test prenant des données paramétriques. Il est souvent utilisé avec l'attribut <code>[InlineData]</code> pour tester différentes valeurs dans un même test. Les théories permettent de tester une méthode avec plusieurs ensembles de données, ce qui est utile pour vérifier le comportement de la méthode sous différentes conditions. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de test paramétrique avec [Theory] et [InlineData]
public class CalculatorTests
{
    [Theory]
    [InlineData(2, 3, 5)]
    [InlineData(-1, 4, 3)]
    [InlineData(0, 0, 0)]
    public void Add_ReturnsCorrectSum(int a, int b, int expected)
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        var result = calculator.Add(a, b);

        // Assert
        Assert.Equal(expected, result);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Assert</strong> : Classe qui contient des méthodes utilisées pour vérifier si les conditions dans un test sont vraies. Par exemple, <code>Assert.Equal()</code> vérifie si deux valeurs sont égales, <code>Assert.True()</code> vérifie si une condition est vraie, et <code>Assert.NotNull()</code> vérifie si un objet n'est pas nul. Les assertions sont essentielles pour valider les résultats des tests et garantir que le code fonctionne comme prévu. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation des assertions
public class CalculatorTests
{
    [Fact]
    public void Add_ReturnsCorrectSum()
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        var result = calculator.Add(2, 3);

        // Assert
        Assert.Equal(5, result); // Vérifie si le résultat est égal à 5
        Assert.True(result &gt; 0); // Vérifie si le résultat est positif
        Assert.NotNull(calculator); // Vérifie si l'objet calculator n'est pas nul
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Test Runner</strong> : Outil ou moteur qui exécute les tests xUnit et rapporte les résultats. Par exemple, Visual Studio Test Runner ou la commande <code>dotnet test</code> peuvent être utilisés pour exécuter les tests et afficher les résultats. Le Test Runner gère l'exécution des tests, collecte les résultats, et fournit des rapports sur les tests réussis et échoués. Exemple d'utilisation :
                            <pre>
                            <code>
// Exécution des tests avec la commande dotnet test
// Ouvrez une console et exécutez la commande suivante dans le répertoire du projet de test
dotnet test
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Test Fixture</strong> : Ensemble d'initialisation partagé entre plusieurs tests. Cela peut inclure la configuration ou les objets partagés utilisés dans les tests. Les fixtures sont utilisées pour réduire la duplication de code et pour configurer un état commun nécessaire à plusieurs tests. Elles peuvent être définies en utilisant des constructeurs ou des méthodes d'initialisation dans les classes de test. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation d'une fixture partagée
public class DatabaseFixture : IDisposable
{
    public DatabaseFixture()
    {
        // Initialisation de la base de données
    }

    public void Dispose()
    {
        // Nettoyage de la base de données
    }
}

public class DatabaseTests : IClassFixture&lt;DatabaseFixture&gt;
{
    private readonly DatabaseFixture _fixture;

    public DatabaseTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public void TestDatabaseConnection()
    {
        // Utilisation de la fixture pour tester la connexion à la base de données
    }
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Gestion des Données -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#dataManagementSection" aria-expanded="false" aria-controls="dataManagementSection">
                    Gestion des Données dans xUnit
                </button>
            </h2>
            <div id="dataManagementSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>[InlineData]</strong> : Attribut qui fournit des valeurs littérales en entrée pour un test marqué avec l'attribut <code>[Theory]</code>. Cela permet de tester différentes combinaisons de paramètres. Par exemple, vous pouvez utiliser <code>[InlineData]</code> pour passer plusieurs ensembles de valeurs à une méthode de test, ce qui permet de vérifier le comportement de la méthode avec différentes entrées sans écrire plusieurs tests distincts. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de test paramétrique avec [InlineData]
public class CalculatorTests
{
    [Theory]
    [InlineData(2, 3, 5)]
    [InlineData(-1, 4, 3)]
    [InlineData(0, 0, 0)]
    public void Add_ReturnsCorrectSum(int a, int b, int expected)
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        var result = calculator.Add(a, b);

        // Assert
        Assert.Equal(expected, result);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>[ClassData]</strong> : Attribut qui permet de fournir des données à un test <code>Theory</code> via une classe externe qui implémente <code>IEnumerable</code>. Cette classe peut encapsuler des ensembles de données complexes et les fournir au test de manière structurée. Cela est utile pour les tests nécessitant des données plus élaborées ou générées dynamiquement. Exemple d'utilisation :
                            <pre>
                            <code>
// Classe de données pour [ClassData]
public class CalculatorTestData : IEnumerable&lt;object[]&gt;
{
    public IEnumerator&lt;object[]&gt; GetEnumerator()
    {
        yield return new object[] { 2, 3, 5 };
        yield return new object[] { -1, 4, 3 };
        yield return new object[] { 0, 0, 0 };
    }

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

// Exemple de test paramétrique avec [ClassData]
public class CalculatorTests
{
    [Theory]
    [ClassData(typeof(CalculatorTestData))]
    public void Add_ReturnsCorrectSum(int a, int b, int expected)
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        var result = calculator.Add(a, b);

        // Assert
        Assert.Equal(expected, result);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>[MemberData]</strong> : Attribut utilisé pour fournir des données à partir d'une propriété ou méthode statique d'une classe qui retourne une collection d'objets ou un tableau. <code>[MemberData]</code> permet de réutiliser des données de test définies ailleurs dans le code, facilitant la maintenance et la gestion des données de test. Les données peuvent être stockées dans des propriétés, des méthodes ou des champs statiques. Exemple d'utilisation :
                            <pre>
                            <code>
// Propriété de données pour [MemberData]
public static IEnumerable&lt;object[]&gt; CalculatorTestData =&gt;
    new List&lt;object[]&gt;
    {
        new object[] { 2, 3, 5 },
        new object[] { -1, 4, 3 },
        new object[] { 0, 0, 0 }
    };

// Exemple de test paramétrique avec [MemberData]
public class CalculatorTests
{
    [Theory]
    [MemberData(nameof(CalculatorTestData))]
    public void Add_ReturnsCorrectSum(int a, int b, int expected)
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        var result = calculator.Add(a, b);

        // Assert
        Assert.Equal(expected, result);
    }
                        }
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Data Driven Tests</strong> : Ensemble de tests paramétrés avec des valeurs multiples, exécutés avec des attributs comme <code>[InlineData]</code>, <code>[ClassData]</code>, ou <code>[MemberData]</code>. Les tests pilotés par les données permettent de valider le comportement d'une méthode avec une variété d'entrées sans dupliquer le code de test. Ils sont particulièrement utiles pour vérifier la robustesse et la fiabilité du code face à différentes conditions d'entrée. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de test piloté par les données avec [InlineData]
public class CalculatorTests
{
    [Theory]
    [InlineData(2, 3, 5)]
    [InlineData(-1, 4, 3)]
    [InlineData(0, 0, 0)]
    public void Add_ReturnsCorrectSum(int a, int b, int expected)
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        var result = calculator.Add(a, b);

        // Assert
        Assert.Equal(expected, result);
    }
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Configuration et Nettoyage -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#setupTeardownSection" aria-expanded="false" aria-controls="setupTeardownSection">
                    Configuration et Nettoyage
                </button>
            </h2>
            <div id="setupTeardownSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>IClassFixture</strong> : Interface qui permet de partager des objets d'initialisation entre différents tests d'une même classe, utilisée pour gérer la configuration ou l'état avant l'exécution des tests. En implémentant <code>IClassFixture</code>, vous pouvez définir une classe de fixture qui sera instanciée une seule fois par classe de test, permettant ainsi de partager des ressources coûteuses ou des configurations complexes entre plusieurs tests. Exemple d'utilisation :
                            <pre>
                            <code>
// Définition d'une fixture
public class DatabaseFixture : IDisposable
{
    public DatabaseFixture()
    {
        // Initialisation des ressources
    }

    public void Dispose()
    {
        // Libération des ressources
    }
}

// Utilisation de la fixture dans une classe de test
public class MyTests : IClassFixture&lt;DatabaseFixture&gt;
{
    private readonly DatabaseFixture _fixture;

    public MyTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public void Test1()
    {
        // Utilisation des ressources partagées
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ICollectionFixture</strong> : Interface permettant de partager des objets d'initialisation à travers plusieurs classes de tests. <code>ICollectionFixture</code> est utile pour partager des ressources ou des configurations entre plusieurs classes de test, en définissant une collection de tests qui partagent la même instance de la fixture. Cela permet de réduire la duplication de code et d'améliorer l'efficacité des tests. Exemple d'utilisation :
                            <pre>
                            <code>
// Définition d'une fixture
public class DatabaseFixture : IDisposable
{
    public DatabaseFixture()
    {
        // Initialisation des ressources
    }

    public void Dispose()
    {
        // Libération des ressources
    }
}

// Définition d'une collection de tests
[CollectionDefinition("Database collection")]
public class DatabaseCollection : ICollectionFixture&lt;DatabaseFixture&gt;
{
}

// Utilisation de la fixture dans une classe de test
[Collection("Database collection")]
public class MyTests1
{
    private readonly DatabaseFixture _fixture;

    public MyTests1(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public void Test1()
    {
        // Utilisation des ressources partagées
    }
}

[Collection("Database collection")]
public class MyTests2
{
    private readonly DatabaseFixture _fixture;

    public MyTests2(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public void Test2()
    {
        // Utilisation des ressources partagées
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Dispose</strong> : Méthode utilisée pour nettoyer ou libérer des ressources à la fin d'un test ou d'une fixture, en implémentant l'interface <code>IDisposable</code>. La méthode <code>Dispose()</code> est appelée automatiquement par le framework de test à la fin de l'exécution des tests, permettant de libérer des ressources telles que des connexions de base de données, des fichiers ouverts, ou d'autres objets coûteux. Exemple d'utilisation :
                            <pre>
                            <code>
// Définition d'une fixture avec Dispose
public class DatabaseFixture : IDisposable
{
    public DatabaseFixture()
    {
        // Initialisation des ressources
    }

    public void Dispose()
    {
        // Libération des ressources
    }
}

// Utilisation de la fixture dans une classe de test
public class MyTests : IClassFixture&lt;DatabaseFixture&gt;
{
    private readonly DatabaseFixture _fixture;

    public MyTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public void Test1()
    {
        // Utilisation des ressources partagées
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Constructor and Dispose Pattern</strong> : Approche courante pour configurer un état partagé dans le constructeur d'une classe de tests et libérer des ressources avec <code>Dispose()</code>. En utilisant ce pattern, vous pouvez initialiser des ressources partagées dans le constructeur de la classe de test et les nettoyer dans la méthode <code>Dispose()</code>, assurant ainsi une gestion efficace des ressources et une isolation appropriée des tests. Exemple d'utilisation :
                            <pre>
                            <code>
// Définition d'une fixture avec constructeur et Dispose
public class DatabaseFixture : IDisposable
{
    public DatabaseFixture()
    {
        // Initialisation des ressources
    }

    public void Dispose()
    {
        // Libération des ressources
    }
}

// Utilisation de la fixture dans une classe de test
public class MyTests : IClassFixture&lt;DatabaseFixture&gt;
{
    private readonly DatabaseFixture _fixture;

    public MyTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public void Test1()
    {
        // Utilisation des ressources partagées
    }
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Tests Asynchrones et Avancés -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#asyncTestsSection" aria-expanded="false" aria-controls="asyncTestsSection">
                    Tests Asynchrones et Avancés
                </button>
            </h2>
            <div id="asyncTestsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Test Asynchrone</strong> : Test qui utilise <code>async</code> et <code>await</code> pour exécuter des méthodes asynchrones dans un test. xUnit supporte nativement les tests asynchrones, ce qui permet de tester des méthodes qui effectuent des opérations asynchrones comme des appels réseau ou des accès à des bases de données sans bloquer le thread de test. Les tests asynchrones sont définis en utilisant la signature <code>public async Task TestMethod()</code>. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de test asynchrone avec xUnit
public class MyAsyncTests
{
    [Fact]
    public async Task TestAsyncMethod()
    {
        // Appel d'une méthode asynchrone
        var result = await SomeAsyncMethod();

        // Assertion sur le résultat
        Assert.Equal(expectedResult, result);
    }

    private async Task&lt;int&gt; SomeAsyncMethod()
    {
        await Task.Delay(1000); // Simule une opération asynchrone
        return 42;
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Assert.ThrowsAsync</strong> : Méthode utilisée pour vérifier qu'une exception est levée lors de l'exécution d'une méthode asynchrone. Par exemple, <code>await Assert.ThrowsAsync&lt;InvalidOperationException&gt;(async () => await SomeAsyncMethod())</code> vérifie que <code>SomeAsyncMethod</code> lève une <code>InvalidOperationException</code>. Cette méthode est essentielle pour tester le comportement des méthodes asynchrones en cas d'erreurs. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de Assert.ThrowsAsync avec xUnit
public class MyAsyncExceptionTests
{
    [Fact]
    public async Task TestAsyncMethodThrowsException()
    {
        // Vérifie qu'une InvalidOperationException est levée
        await Assert.ThrowsAsync&lt;InvalidOperationException&gt;(async () => await SomeAsyncMethod());
    }

    private async Task SomeAsyncMethod()
    {
        await Task.Delay(1000); // Simule une opération asynchrone
        throw new InvalidOperationException("An error occurred");
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Fluent Assertions</strong> : Extension populaire pour les assertions dans xUnit, permettant d'écrire des tests plus expressifs avec une syntaxe fluide. Fluent Assertions offre une large gamme de méthodes d'assertion qui rendent les tests plus lisibles et maintenables. Par exemple, au lieu d'utiliser <code>Assert.Equal(expected, actual)</code>, vous pouvez écrire <code>actual.Should().Be(expected)</code>, ce qui améliore la clarté des tests. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de Fluent Assertions avec xUnit
public class MyFluentAssertionsTests
{
    [Fact]
    public void TestWithFluentAssertions()
    {
        int actual = 42;
        int expected = 42;

        // Utilisation de Fluent Assertions
        actual.Should().Be(expected);
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Mocking</strong> : Pratique consistant à simuler des objets ou des services externes dans les tests, souvent utilisée avec des bibliothèques comme Moq ou NSubstitute. Le mocking permet de créer des objets factices qui imitent le comportement des dépendances réelles, facilitant ainsi le test des composants en isolation. Par exemple, vous pouvez utiliser Moq pour créer un mock d'un service de base de données et définir des comportements spécifiques pour les méthodes de ce service. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de Moq pour le mocking avec xUnit
public class MyMockingTests
{
    [Fact]
    public void TestWithMocking()
    {
        // Création d'un mock d'un service
        var mockService = new Mock&lt;IMyService&gt;();

        // Définition du comportement du mock
        mockService.Setup(service => service.GetData()).Returns("Mocked Data");

        // Utilisation du mock dans un test
        var result = mockService.Object.GetData();

        // Assertion sur le résultat
        result.Should().Be("Mocked Data");
    }
}

public interface IMyService
{
    string GetData();
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Bonnes Pratiques -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#bestPracticesSection" aria-expanded="false" aria-controls="bestPracticesSection">
                    Bonnes Pratiques avec xUnit
                </button>
            </h2>
            <div id="bestPracticesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Nommer les Tests</strong> : Utilisez des noms explicites qui décrivent clairement ce qui est testé et quelles sont les attentes. Par exemple, au lieu de nommer un test <code>Test1</code>, utilisez un nom comme <code>ShouldReturnTrueWhenInputIsValid</code>. Cela rend les tests plus compréhensibles et facilite le diagnostic des échecs de test. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de nommage explicite des tests avec xUnit
public class MyTests
{
    [Fact]
    public void ShouldReturnTrueWhenInputIsValid()
    {
        // Configuration du test
        var input = "validInput";
        var expectedResult = true;

        // Exécution de la méthode testée
        var result = MyMethod(input);

        // Assertion sur le résultat
        Assert.Equal(expectedResult, result);
    }

    private bool MyMethod(string input)
    {
        // Logique de la méthode
        return input == "validInput";
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Tests Isolés</strong> : Assurez-vous que chaque test est indépendant des autres et qu'il n'y a pas de dépendances partagées qui pourraient causer des interférences. Utilisez des mocks ou des stubs pour isoler les dépendances externes et garantir que les tests ne sont pas affectés par l'état global ou les effets secondaires d'autres tests. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de Moq pour isoler les dépendances avec xUnit
public class MyTests
{
    [Fact]
    public void TestMethod()
    {
        // Création d'un mock d'un service
        var mockService = new Mock&lt;IMyService&gt;();

        // Définition du comportement du mock
        mockService.Setup(service => service.GetData()).Returns("Mocked Data");

        // Utilisation du mock dans un test
        var result = mockService.Object.GetData();

        // Assertion sur le résultat
        Assert.Equal("Mocked Data", result);
    }
}

public interface IMyService
{
    string GetData();
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Coverage</strong> : Utilisez des outils de couverture de code comme Coverlet pour mesurer et améliorer la couverture des tests. La couverture de code indique quelles parties du code sont exécutées par les tests, aidant à identifier les zones non testées. Une couverture élevée ne garantit pas l'absence de bugs, mais elle augmente la confiance dans la qualité du code. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'utilisation de Coverlet pour mesurer la couverture de code
// Ajoutez Coverlet comme outil de test dans le fichier .csproj
&lt;ItemGroup&gt;
    &lt;PackageReference Include="coverlet.collector" Version="3.0.3" /&gt;
&lt;/ItemGroup&gt;

// Exécutez les tests avec la collecte de couverture de code
dotnet test --collect:"XPlat Code Coverage"

// Générez un rapport de couverture de code
reportgenerator -reports:coverage.cobertura.xml -targetdir:coveragereport
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Refactorisation et Tests</strong> : Refactorisez régulièrement le code des tests pour le rendre plus lisible et maintenable. La refactorisation des tests inclut la suppression des duplications, l'amélioration des noms de méthodes et de variables, et la simplification des assertions. Un code de test propre et bien structuré facilite la maintenance et l'évolution des tests à mesure que le code de production change. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de refactorisation des tests avec xUnit
public class MyTests
{
    [Fact]
    public void ShouldReturnTrueWhenInputIsValid()
    {
        // Configuration du test
        var input = "validInput";
        var expectedResult = true;

        // Exécution de la méthode testée
        var result = MyMethod(input);

        // Assertion sur le résultat
        Assert.Equal(expectedResult, result);
    }

    [Fact]
    public void ShouldReturnFalseWhenInputIsInvalid()
    {
        // Configuration du test
        var input = "invalidInput";
        var expectedResult = false;

        // Exécution de la méthode testée
        var result = MyMethod(input);

        // Assertion sur le résultat
        Assert.Equal(expectedResult, result);
    }

    private bool MyMethod(string input)
    {
        // Logique de la méthode
        return input == "validInput";
    }
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire Entity Framework Core</h1>

    <div class="accordion">
        <!-- Section DbContext -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#dbContextSection" aria-expanded="false" aria-controls="dbContextSection">
                    DbContext
                </button>
            </h2>
            <div id="dbContextSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>DbContext</strong> : Classe centrale qui gère les requêtes et les modifications à la base de données. Le <code>DbContext</code> est responsable de la gestion de la connexion à la base de données, du suivi des modifications apportées aux entités, et de la coordination des opérations de sauvegarde et de récupération des données. Exemple :
                            <pre>
                            <code>
public class ApplicationDbContext : DbContext
{
    public DbSet&lt;Product&gt; Products { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("YourConnectionString");
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>DbSet&lt;T&gt;</strong> : Représente une collection d'entités d'un type particulier dans le contexte. Un <code>DbSet</code> permet de créer, lire, mettre à jour et supprimer des entités de la base de données. Exemple :
                            <pre>
                            <code>
public class ApplicationDbContext : DbContext
{
    public DbSet&lt;Customer&gt; Customers { get; set; }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>OnModelCreating</strong> : Méthode dans laquelle les configurations du modèle de données sont définies (mappage entre les entités et la base de données). Cette méthode est utilisée pour configurer les relations, les contraintes et les conventions de nommage des tables et des colonnes. Exemple :
                            <pre>
                            <code>
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity&lt;Product&gt;().HasKey(p => p.ProductId);
    modelBuilder.Entity&lt;Product&gt;().Property(p => p.Name).IsRequired().HasMaxLength(100);
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>SaveChanges</strong> : Méthode pour enregistrer les modifications faites aux entités dans la base de données. Cette méthode envoie toutes les modifications suivies par le <code>DbContext</code> à la base de données. Exemple :
                            <pre>
                            <code>
using (var context = new ApplicationDbContext())
{
    var product = new Product { Name = "New Product" };
    context.Products.Add(product);
    context.SaveChanges();
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ChangeTracker</strong> : Suit les modifications des entités gérées par le DbContext. Le <code>ChangeTracker</code> permet de détecter les changements apportés aux entités et de déterminer quelles opérations doivent être effectuées lors de l'appel à <code>SaveChanges</code>. Exemple :
                            <pre>
                            <code>
using (var context = new ApplicationDbContext())
{
    var product = context.Products.First();
    product.Name = "Updated Product";
    var entries = context.ChangeTracker.Entries();
    foreach (var entry in entries)
    {
        Console.WriteLine($"{entry.Entity.GetType().Name} - {entry.State}");
    }
    context.SaveChanges();
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Lazy Loading</strong> : Chargement différé des données, les relations ne sont récupérées que lorsqu'elles sont accédées. Cela permet d'optimiser les performances en ne chargeant pas toutes les données liées immédiatement. Exemple :
                            <pre>
                            <code>
public class Customer
{
    public int CustomerId { get; set; }
    public string Name { get; set; }
    public virtual ICollection&lt;Order&gt; Orders { get; set; } // Lazy loading enabled
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Explicit Loading</strong> : Chargement explicite des données liées via des méthodes comme <code>Load()</code>. Utilisé lorsque le lazy loading est désactivé ou pour un contrôle plus précis sur le moment où les données sont chargées. Exemple :
                            <pre>
                            <code>
using (var context = new ApplicationDbContext())
{
    var customer = context.Customers.First();
    context.Entry(customer).Collection(c => c.Orders).Load();
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Query Tracking</strong> : Contrôle si les entités récupérées sont suivies pour détecter les modifications. Par défaut, les entités récupérées sont suivies, mais cela peut être désactivé pour améliorer les performances en utilisant <code>AsNoTracking()</code>. Exemple :
                            <pre>
                            <code>
using (var context = new ApplicationDbContext())
{
    var customers = context.Customers.AsNoTracking().ToList();
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Migrations -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#migrationsSection" aria-expanded="false" aria-controls="migrationsSection">
                    Migrations
                </button>
            </h2>
            <div id="migrationsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Migration</strong> : Classe qui représente une modification de la structure de la base de données. Une migration contient des instructions pour créer, modifier ou supprimer des tables et des colonnes. Elle permet de synchroniser le modèle de données avec la base de données. Exemple :
                            <pre>
                            <code>
public partial class AddProductTable : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "Products",
            columns: table => new
            {
                Id = table.Column&lt;int&gt;(nullable: false)
                    .Annotation("SqlServer:Identity", "1, 1"),
                Name = table.Column&lt;string&gt;(nullable: true)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_Products", x => x.Id);
            });
    }

    protected override void Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(name: "Products");
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Add-Migration</strong> : Commande pour générer une nouvelle migration basée sur les modifications apportées au modèle. Cette commande crée un fichier de migration contenant les instructions nécessaires pour appliquer les changements à la base de données. Exemple :
                            <pre><code>dotnet ef migrations add AddProductTable</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Update-Database</strong> : Commande pour appliquer les migrations à la base de données. Elle exécute les instructions contenues dans les fichiers de migration pour mettre à jour la structure de la base de données. Exemple :
                            <pre><code>dotnet ef database update</code></pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Down</strong> : Méthode d'une migration qui défait les modifications appliquées. Cette méthode est utilisée pour annuler les changements apportés par la méthode <code>Up</code>. Exemple :
                            <pre>
                            <code>
protected override void Down(MigrationBuilder migrationBuilder)
{
    migrationBuilder.DropTable(name: "Products");
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Up</strong> : Méthode d'une migration qui définit les modifications à appliquer à la base de données. Cette méthode contient les instructions pour créer, modifier ou supprimer des éléments de la base de données. Exemple :
                            <pre>
                            <code>
protected override void Up(MigrationBuilder migrationBuilder)
{
    migrationBuilder.CreateTable(
        name: "Products",
        columns: table => new
        {
            Id = table.Column&lt;int&gt;(nullable: false)
                .Annotation("SqlServer:Identity", "1, 1"),
            Name = table.Column&lt;string&gt;(nullable: true)
        },
        constraints: table =>
        {
            table.PrimaryKey("PK_Products", x => x.Id);
        });
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Rollback</strong> : Revenir à une migration antérieure en annulant les migrations appliquées après celle-ci. Cette opération utilise les méthodes <code>Down</code> des migrations pour annuler les changements. Exemple :
                            <pre><code>dotnet ef database update PreviousMigration</code></pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Entities -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#entitiesSection" aria-expanded="false" aria-controls="entitiesSection">
                    Entities
                </button>
            </h2>
            <div id="entitiesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Entity</strong> : Classe C# qui représente une table dans la base de données. Une entité contient des propriétés qui correspondent aux colonnes de la table. Exemple :
                            <pre>
                            <code>
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
}
                                </code>
                            </pre>
                            Cela représente une table "Product" avec des colonnes "Id" et "Name".
                        </li>
                        <li class="list-group-item">
                            <strong>Primary Key</strong> : Propriété ou ensemble de propriétés identifiant de manière unique une entité. La clé primaire est utilisée pour garantir l'unicité de chaque enregistrement dans la table. Exemple :
                            <pre>
                            <code>
public class Product
{
    [Key]
    public int Id { get; set; }
}
                                </code>
                            </pre>
                            Cela définit "Id" comme clé primaire.
                        </li>
                        <li class="list-group-item">
                            <strong>Foreign Key</strong> : Clé étrangère qui établit une relation entre deux entités. Elle permet de lier une entité à une autre en utilisant une clé primaire d'une autre table. Exemple :
                            <pre>
                            <code>
public class Order
{
    public int Id { get; set; }
    public int ProductId { get; set; }

    [ForeignKey("ProductId")]
    public Product Product { get; set; }
}
                                </code>
                            </pre>
                            Cela définit "ProductId" comme clé étrangère reliant "Order" à "Product".
                        </li>
                        <li class="list-group-item">
                            <strong>Navigation Property</strong> : Propriété utilisée pour accéder aux entités liées (relations entre tables). Les propriétés de navigation permettent de naviguer entre les entités liées. Exemple :
                            <pre>
                            <code>
public class Order
{
    public int Id { get; set; }
    public int ProductId { get; set; }
    public Product Product { get; set; }
}
                                </code>
                            </pre>
                            Cela permet d'accéder à l'entité "Product" depuis "Order".
                        </li>
                        <li class="list-group-item">
                            <strong>Data Annotations</strong> : Attributs utilisés pour configurer le comportement des propriétés d'entité. Les annotations de données permettent de définir des contraintes et des règles de validation. Exemple :
                            <pre>
                            <code>
public class Product
{
    [Key]
    public int Id { get; set; }

    [Required]
    [MaxLength(100)]
    public string Name { get; set; }
}
                                </code>
                            </pre>
                            Cela utilise les annotations <code>[Key]</code>, <code>[Required]</code>, et <code>[MaxLength(100)]</code> pour configurer les propriétés de l'entité "Product".
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section LINQ et Requêtes -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#linqSection" aria-expanded="false" aria-controls="linqSection">
                    LINQ et Requêtes
                </button>
            </h2>
            <div id="linqSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>LINQ</strong> : Language Integrated Query, permet d'écrire des requêtes pour interroger des collections d'entités. LINQ offre une syntaxe cohérente pour interroger des données provenant de différentes sources (collections en mémoire, bases de données, XML, etc.). Exemple :
                            <pre>
                            <code>
var query = from p in products
where p.Price > 100
select p;
                                </code>
                            </pre>
                            Cela sélectionne les produits dont le prix est supérieur à 100.
                        </li>
                        <li class="list-group-item">
                            <strong>Where</strong> : Méthode pour filtrer les entités selon une condition. Elle permet de sélectionner uniquement les éléments qui satisfont une condition spécifiée. Exemple :
                            <pre><code>var expensiveProducts = products.Where(p =&gt; p.Price &gt; 100);</code></pre>
                            Cela obtient les produits dont le prix est supérieur à 100.
                        </li>
                        <li class="list-group-item">
                            <strong>Include</strong> : Méthode pour charger les relations associées à une entité. Utilisée avec Entity Framework pour inclure des données liées dans les résultats de la requête. Exemple :
                            <pre><code>var orders = context.Orders.Include(o =&gt; o.Customer).ToList();</code></pre>
                            Cela charge les commandes avec les informations des clients associés.
                        </li>
                        <li class="list-group-item">
                            <strong>FirstOrDefault</strong> : Méthode qui renvoie la première entité correspondant à une condition ou une valeur par défaut si aucune entité ne correspond. Elle est utilisée pour obtenir un seul élément d'une collection. Exemple :
                            <pre><code>var firstProduct = products.FirstOrDefault(p =&gt; p.Name == "Laptop");</code></pre>
                            Cela obtient le premier produit nommé "Laptop" ou <code>null</code> s'il n'existe pas.
                        </li>
                        <li class="list-group-item">
                            <strong>ToList</strong> : Méthode pour exécuter une requête et convertir le résultat en liste. Elle force l'exécution immédiate de la requête et retourne les résultats sous forme de liste. Exemple :
                            <pre><code>var productList = products.Where(p =&gt; p.Price &gt; 100).ToList();</code></pre>
                            Cela obtient une liste de produits dont le prix est supérieur à 100.
                        </li>
                        <li class="list-group-item">
                            <strong>AsNoTracking</strong> : Exécute une requête sans suivre les entités récupérées dans le ChangeTracker. Utilisée pour améliorer les performances lorsque le suivi des modifications n'est pas nécessaire. Exemple :
                            <pre><code>var customers = context.Customers.AsNoTracking().ToList();</code></pre>
                            Cela récupère les clients sans suivi des modifications.
                        </li>
                        <li class="list-group-item">
                            <strong>GroupBy</strong> : Méthode pour regrouper les résultats selon une clé. Elle permet de créer des groupes d'éléments partageant une même valeur de clé. Exemple :
                            <pre><code>var productsByCategory = products.GroupBy(p =&gt; p.Category);</code></pre>
                            Cela regroupe les produits par catégorie.
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Configurations Avancées -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#advancedConfigSection" aria-expanded="false" aria-controls="advancedConfigSection">
                    Configurations Avancées
                </button>
            </h2>
            <div id="advancedConfigSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Fluent API</strong> : API permettant de configurer les relations entre les entités et les propriétés sans utiliser les annotations de données. Elle offre une syntaxe fluide et expressive pour configurer le modèle de données dans la méthode <code>OnModelCreating</code> du <code>DbContext</code>. Exemple :
                            <pre>
                            <code>
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity&lt;Product&gt;()
        .HasKey(p =&gt; p.Id);

    modelBuilder.Entity&lt;Product&gt;()
        .Property(p =&gt; p.Name)
        .IsRequired()
        .HasMaxLength(100);
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>HasKey</strong> : Utilisé pour définir la clé primaire d'une entité. Cette méthode spécifie quelle propriété ou quelles propriétés constituent la clé primaire. Exemple :
                            <pre>
                            <code>
modelBuilder.Entity&lt;Product&gt;()
.HasKey(p =&gt; p.Id);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>HasOne</strong> : Utilisé pour configurer une relation un-à-un ou un-à-plusieurs entre les entités. Cette méthode spécifie qu'une entité a une relation avec une autre entité. Exemple :
                            <pre>
                            <code>
modelBuilder.Entity&lt;Order&gt;()
.HasOne(o =&gt; o.Customer)
.WithMany(c =&gt; c.Orders)
.HasForeignKey(o =&gt; o.CustomerId);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>HasMany</strong> : Utilisé pour configurer une relation plusieurs-à-un ou plusieurs-à-plusieurs entre les entités. Cette méthode spécifie qu'une entité a plusieurs relations avec une autre entité. Exemple :
                            <pre>
                            <code>
modelBuilder.Entity&lt;Customer&gt;()
.HasMany(c =&gt; c.Orders)
.WithOne(o =&gt; o.Customer)
.HasForeignKey(o =&gt; o.CustomerId);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ToTable</strong> : Méthode utilisée pour spécifier le nom de la table correspondant à une entité. Cela permet de mapper une entité à une table spécifique dans la base de données. Exemple :
                            <pre>
                            <code>
modelBuilder.Entity&lt;Product&gt;()
.ToTable("Products");
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Seed Data</strong> : Ensemble de données initiales insérées automatiquement dans la base de données lors de la migration. Utilisé pour pré-remplir la base de données avec des données de test ou des valeurs par défaut. Exemple :
                            <pre>
                            <code>
modelBuilder.Entity&lt;Product&gt;().HasData(
new Product { Id = 1, Name = "Laptop" },
new Product { Id = 2, Name = "Smartphone" });
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire LINQ (Language Integrated Query)</h1>

    <div class="accordion">
        <!-- Section LINQ Overview -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#linqOverviewSection" aria-expanded="false" aria-controls="linqOverviewSection">
                    Aperçu de LINQ
                </button>
            </h2>
            <div id="linqOverviewSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>LINQ</strong> : Un ensemble de fonctionnalités de .NET pour interroger et manipuler des collections de données de manière déclarative. LINQ (Language Integrated Query) permet d'écrire des requêtes directement dans le code C# en utilisant une syntaxe similaire à SQL. Exemple :
                            <pre>
                            <code>
var query = from p in products
where p.Price > 100
select p;
                                </code>
                            </pre>
                            Cela sélectionne les produits dont le prix est supérieur à 100.
                        </li>
                        <li class="list-group-item">
                            <strong>LINQ to Objects</strong> : Utilisation de LINQ pour interroger des collections en mémoire, comme des listes, tableaux, etc. Cela permet de manipuler des données en mémoire de manière déclarative. Exemple :
                            <pre>
                            <code>
List&lt;int&gt; numbers = new List&lt;int&gt; { 1, 2, 3, 4, 5 };
var evenNumbers = from n in numbers
                    where n % 2 == 0
                    select n;
                                </code>
                            </pre>
                            Cela sélectionne les nombres pairs de la liste.
                        </li>
                        <li class="list-group-item">
                            <strong>LINQ to SQL</strong> : Utilisation de LINQ pour interroger des bases de données SQL via des objets C#. LINQ to SQL permet de mapper des classes C# à des tables de base de données et d'écrire des requêtes en utilisant LINQ. Exemple :
                            <pre>
                            <code>
DataContext db = new DataContext("connectionString");
var query = from c in db.GetTable&lt;Customer&gt;()
            where c.City == "Paris"
            select c;
                                </code>
                            </pre>
                            Cela sélectionne les clients dont la ville est "Paris".
                        </li>
                        <li class="list-group-item">
                            <strong>LINQ to XML</strong> : Permet de manipuler et interroger des documents XML en utilisant LINQ. LINQ to XML offre une API fluide pour travailler avec des documents XML. Exemple :
                            <pre>
                            <code>
XDocument doc = XDocument.Load("data.xml");
var query = from e in doc.Descendants("Employee")
            where (int)e.Element("Age") > 30
            select e;
                                </code>
                            </pre>
                            Cela sélectionne les employés dont l'âge est supérieur à 30.
                        </li>
                        <li class="list-group-item">
                            <strong>LINQ to Entities</strong> : Utilisé pour interroger des bases de données via Entity Framework. LINQ to Entities permet d'écrire des requêtes LINQ pour interagir avec des entités mappées à des tables de base de données. Exemple :
                            <pre>
                            <code>
var query = from o in context.Orders
where o.OrderDate &gt; DateTime.Now.AddDays(-30)
select o;
                                </code>
                            </pre>
                            Cela sélectionne les commandes passées au cours des 30 derniers jours.
                        </li>
                        <li class="list-group-item">
                            <strong>Deferred Execution</strong> : L'exécution des requêtes LINQ est différée jusqu'à ce que les données soient réellement demandées. Cela signifie que la requête n'est pas exécutée au moment de sa définition, mais au moment où les données sont itérées. Exemple :
                            <pre>
                            <code>
var query = from p in products
where p.Price > 100
select p;

// La requête est exécutée ici, lorsque les données sont demandées
foreach (var product in query)
{
    Console.WriteLine(product.Name);
}
                                </code>
                            </pre>
                            Cela permet d'optimiser les performances en retardant l'exécution jusqu'à ce que les données soient nécessaires.
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Méthodes de requêtes LINQ -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#linqMethodsSection" aria-expanded="false" aria-controls="linqMethodsSection">
                    Méthodes de Requête LINQ
                </button>
            </h2>
            <div id="linqMethodsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Where</strong> : Filtre les éléments d'une collection en fonction d'une condition. Cette méthode retourne uniquement les éléments qui satisfont la condition spécifiée. Exemple :
                            <pre><code>var adults = collection.Where(x => x.Age > 18);</code></pre>
                            Cela sélectionne les éléments dont l'âge est supérieur à 18.
                        </li>
                        <li class="list-group-item">
                            <strong>Select</strong> : Projette les éléments d'une collection dans une nouvelle forme. Cette méthode permet de transformer chaque élément d'une collection en un nouveau type. Exemple :
                            <pre><code>var names = collection.Select(x => x.Name);</code></pre>
                            Cela sélectionne les noms des éléments de la collection.
                        </li>
                        <li class="list-group-item">
                            <strong>OrderBy / OrderByDescending</strong> : Trie les éléments d'une collection par ordre croissant ou décroissant. <code>OrderBy</code> trie par ordre croissant, tandis que <code>OrderByDescending</code> trie par ordre décroissant. Exemple :
                            <pre>
                            <code>
var sortedByAge = collection.OrderBy(x => x.Age);
var sortedByAgeDesc = collection.OrderByDescending(x => x.Age);
                                </code>
                            </pre>
                            Cela trie les éléments par âge en ordre croissant et décroissant respectivement.
                        </li>
                        <li class="list-group-item">
                            <strong>GroupBy</strong> : Regroupe les éléments d'une collection par clé. Cette méthode permet de créer des groupes d'éléments partageant une même valeur de clé. Exemple :
                            <pre><code>var groupedByCategory = collection.GroupBy(x => x.Category);</code></pre>
                            Cela regroupe les éléments par catégorie.
                        </li>
                        <li class="list-group-item">
                            <strong>Join</strong> : Jointure entre deux collections en fonction d'une clé commune. Cette méthode permet de combiner des éléments de deux collections différentes en fonction d'une clé partagée. Exemple :
                            <pre><code>var joined = collection1.Join(collection2, x => x.Id, y => y.Id, (x, y) => new { x.Name, y.Description });</code></pre>
                            Cela joint les deux collections sur la clé <code>Id</code> et crée une nouvelle collection avec les propriétés <code>Name</code> et <code>Description</code>.
                        </li>
                        <li class="list-group-item">
                            <strong>First / FirstOrDefault</strong> : Retourne le premier élément d'une collection, ou une valeur par défaut si aucun élément n'est trouvé. <code>First</code> lève une exception si aucun élément n'est trouvé, tandis que <code>FirstOrDefault</code> retourne <code>null</code> ou la valeur par défaut du type. Exemple :
                            <pre>
                            <code>
var firstJohn = collection.First(x => x.Name == "John");
var firstOrDefaultJohn = collection.FirstOrDefault(x => x.Name == "John");
                                </code>
                            </pre>
                            Cela retourne le premier élément nommé "John" ou <code>null</code> si aucun n'est trouvé.
                        </li>
                        <li class="list-group-item">
                            <strong>Single / SingleOrDefault</strong> : Retourne un élément unique ou une exception si plusieurs éléments correspondent. <code>Single</code> lève une exception si aucun ou plusieurs éléments sont trouvés, tandis que <code>SingleOrDefault</code> retourne <code>null</code> ou la valeur par défaut du type si aucun élément n'est trouvé. Exemple :
                            <pre>
                            <code>
var singleItem = collection.Single(x => x.Id == 1);
var singleOrDefaultItem = collection.SingleOrDefault(x => x.Id == 1);
                                </code>
                            </pre>
                            Cela retourne l'élément unique avec l'Id 1 ou <code>null</code> si aucun n'est trouvé.
                        </li>
                        <li class="list-group-item">
                            <strong>Count</strong> : Retourne le nombre d'éléments d'une collection. Cette méthode compte le nombre total d'éléments dans la collection. Exemple :
                            <pre><code>var count = collection.Count();</code></pre>
                            Cela retourne le nombre total d'éléments dans la collection.
                        </li>
                        <li class="list-group-item">
                            <strong>Sum</strong> : Retourne la somme des valeurs numériques d'une collection. Cette méthode additionne les valeurs d'une propriété numérique de chaque élément de la collection. Exemple :
                            <pre><code>var totalPrice = collection.Sum(x => x.Price);</code></pre>
                            Cela retourne la somme des prix des éléments de la collection.
                        </li>
                        <li class="list-group-item">
                            <strong>Average</strong> : Retourne la moyenne des valeurs numériques d'une collection. Cette méthode calcule la moyenne des valeurs d'une propriété numérique de chaque élément de la collection. Exemple :
                            <pre><code>var averageScore = collection.Average(x => x.Score);</code></pre>
                            Cela retourne la moyenne des scores des éléments de la collection.
                        </li>
                        <li class="list-group-item">
                            <strong>Min / Max</strong> : Retourne la valeur minimale ou maximale d'une collection. <code>Min</code> retourne la plus petite valeur, tandis que <code>Max</code> retourne la plus grande valeur d'une propriété numérique. Exemple :
                            <pre><code>var minPrice = collection.Min(x => x.Price);
                        var maxPrice = collection.Max(x => x.Price);</code></pre>
                            Cela retourne le prix minimum et maximum des éléments de la collection.
                        </li>
                        <li class="list-group-item">
                            <strong>Distinct</strong> : Supprime les doublons d'une collection. Cette méthode retourne une nouvelle collection contenant uniquement des éléments uniques. Exemple :
                            <pre><code>var distinctItems = collection.Distinct();</code></pre>
                            Cela retourne une collection sans doublons.
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Syntaxe de requête LINQ -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#linqSyntaxSection" aria-expanded="false" aria-controls="linqSyntaxSection">
                    Syntaxe de Requête LINQ
                </button>
            </h2>
            <div id="linqSyntaxSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Query Syntax</strong> : Style de requête qui ressemble aux requêtes SQL. Utilisé pour écrire des requêtes de manière déclarative, similaire à SQL. La syntaxe de requête est souvent plus lisible pour ceux qui sont familiers avec SQL. Exemple :
                            <pre>
                            <code>
var adults = from x in collection
where x.Age > 18
select x;
                                </code>
                            </pre>
                            Cela sélectionne tous les éléments de la collection où l'âge est supérieur à 18.
                        </li>
                        <li class="list-group-item">
                            <strong>Method Syntax</strong> : Style de requête utilisant des méthodes de chaîne (enchaînement de méthodes). Utilisé pour écrire des requêtes en utilisant des méthodes d'extension LINQ. La syntaxe de méthode est souvent plus concise et expressive. Exemple :
                            <pre>
                            <code>
var names = collection.Where(x => x.Age > 18)
.Select(x => x.Name);
                                </code>
                            </pre>
                            Cela filtre les éléments où l'âge est supérieur à 18 et sélectionne les noms des éléments.
                        </li>
                        <li class="list-group-item">
                            <strong>Let</strong> : Mot-clé utilisé dans les requêtes pour stocker des résultats intermédiaires. Utilisé pour créer des variables temporaires dans une requête LINQ, ce qui peut simplifier les requêtes complexes et améliorer la lisibilité. Exemple :
                            <pre>
                            <code>
var query = from x in collection
let total = x.Quantity * x.Price
where total > 100
select new { x.Name, Total = total };
                                </code>
                            </pre>
                            Cela calcule le total pour chaque élément en multipliant la quantité par le prix, puis sélectionne les éléments où le total est supérieur à 100.
                        </li>
                        <li class="list-group-item">
                            <strong>Into</strong> : Permet de continuer une requête après un groupement ou une jointure. Utilisé pour créer une nouvelle portée pour les résultats groupés ou joints, ce qui permet de continuer à manipuler les résultats. Exemple :
                            <pre>
                            <code>
var grouped = from x in collection
group x by x.Category into g
select new { Category = g.Key, Items = g.ToList() };
                                </code>
                                </pre>
                            Cela regroupe les éléments par catégorie et permet de continuer la requête avec le groupe <code>g</code>.
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Performances et Optimisation -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#linqPerformanceSection" aria-expanded="false" aria-controls="linqPerformanceSection">
                    Performances et Optimisation
                </button>
            </h2>
            <div id="linqPerformanceSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Deferred Execution</strong> : Requêtes LINQ qui ne sont pas exécutées immédiatement mais lorsqu'elles sont itérées. Cela permet d'optimiser les performances en retardant l'exécution jusqu'à ce que les résultats soient réellement nécessaires. Par exemple, une requête LINQ ne sera exécutée que lorsque vous itérez sur les résultats avec une boucle <code>foreach</code> ou que vous appelez une méthode comme <code>ToList()</code>. Exemple :
                            <pre>
                            <code>
var query = collection.Where(x => x.Age > 18);
// La requête est exécutée ici, lorsque les données sont demandées
foreach (var item in query)
{
    Console.WriteLine(item.Name);
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Immediate Execution</strong> : Requêtes qui sont exécutées immédiatement via des méthodes comme <code>ToList()</code> ou <code>Count()</code>. Ces méthodes forcent l'exécution de la requête et retournent les résultats immédiatement. Exemple :
                            <pre><code>var result = collection.ToList();</code></pre>
                            Cela exécute la requête et stocke les résultats dans une liste.
                        </li>
                        <li class="list-group-item">
                            <strong>AsNoTracking</strong> : Utilisé avec Entity Framework pour améliorer les performances en désactivant le suivi des entités. Lorsque vous utilisez <code>AsNoTracking()</code>, les entités récupérées ne sont pas suivies par le <code>ChangeTracker</code>, ce qui réduit la surcharge de mémoire et améliore les performances des requêtes en lecture seule. Exemple :
                            <pre><code>var customers = context.Customers.AsNoTracking().ToList();</code></pre>
                            Cela récupère les clients sans suivi des modifications.
                        </li>
                        <li class="list-group-item">
                            <strong>Projection</strong> : Technique pour sélectionner uniquement les données nécessaires pour améliorer les performances. En utilisant des projections, vous pouvez réduire la quantité de données transférées et traitées. Exemple :
                            <pre><code>var names = collection.Select(x => x.Name).ToList();</code></pre>
                            Cela sélectionne uniquement les noms des éléments, réduisant ainsi la charge de données.
                        </li>
                        <li class="list-group-item">
                            <strong>Optimize Joins</strong> : Assurez-vous d'utiliser <code>Join</code> avec les relations appropriées pour éviter des requêtes SQL inefficaces. L'optimisation des jointures permet de réduire le nombre de requêtes et d'améliorer les performances globales. Exemple :
                            <pre>
                            <code>
var result = from a in context.TableA
join b in context.TableB on a.Id equals b.AId
select new { a, b };
                                </code>
                            </pre>
                            Cela effectue une jointure efficace entre deux tables.
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Outils et Extensions LINQ -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#linqToolsSection" aria-expanded="false" aria-controls="linqToolsSection">
                    Outils et Extensions LINQ
                </button>
            </h2>
            <div id="linqToolsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>LINQPad</strong> : Outil pour tester et interagir avec les requêtes LINQ. LINQPad permet d'exécuter des requêtes LINQ, de visualiser les résultats et de déboguer les requêtes. Il prend en charge LINQ to SQL, LINQ to Entities, LINQ to XML, et bien plus encore. C'est un outil indispensable pour les développeurs travaillant avec LINQ. Exemple d'utilisation :
                            <pre>
                            <code>
// Écrire et exécuter une requête LINQ dans LINQPad
var query = from p in Products
            where p.Price > 100
            select p;
query.Dump(); // Dump() est une méthode spécifique à LINQPad pour afficher les résultats
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ReSharper</strong> : Outil de productivité qui améliore la prise en charge des requêtes LINQ dans Visual Studio. ReSharper offre des fonctionnalités avancées de refactoring, de navigation et d'analyse de code, ce qui facilite l'écriture et l'optimisation des requêtes LINQ. Il propose également des suggestions pour améliorer les performances et la lisibilité du code. Exemple d'utilisation :
                            <pre>
                            <code>
// ReSharper peut suggérer des améliorations pour les requêtes LINQ
var query = collection.Where(x => x.Age > 18).Select(x => x.Name);
// ReSharper peut suggérer de combiner les méthodes pour améliorer la lisibilité
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Dynamic LINQ</strong> : Permet de créer des requêtes LINQ à partir de chaînes, souvent utilisé dans les applications dynamiques. Dynamic LINQ est utile lorsque les requêtes doivent être construites de manière dynamique à l'exécution, par exemple, en fonction des entrées utilisateur. Il permet de générer des requêtes complexes sans avoir à écrire de code LINQ statique. Exemple d'utilisation :
                            <pre>
                            <code>
using System.Linq.Dynamic.Core;

var query = collection.AsQueryable().Where("Age > 18").Select("Name");
                                </code>
                            </pre>
                            Cela permet de créer des requêtes LINQ dynamiques à partir de chaînes.
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire SQL</h1>

    <div class="accordion">
        <!-- Section Requêtes de Base -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#basicQueriesSection" aria-expanded="false" aria-controls="basicQueriesSection">
                    Requêtes de Base
                </button>
            </h2>
            <div id="basicQueriesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>SELECT</strong> : Extrait des données d'une ou plusieurs tables. La clause SELECT est utilisée pour spécifier les colonnes que vous souhaitez récupérer dans une requête SQL. Elle peut être utilisée avec d'autres clauses comme WHERE, ORDER BY, et GROUP BY pour affiner les résultats. Exemple d'utilisation :
                            <pre>
                            <code>
-- Sélection de toutes les colonnes d'une table
SELECT * FROM Employees;

-- Sélection de colonnes spécifiques
SELECT FirstName, LastName FROM Employees;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>FROM</strong> : Spécifie la ou les tables à partir desquelles les données seront extraites. La clause FROM est utilisée pour indiquer la source des données dans une requête SQL. Elle peut inclure des jointures pour combiner des données de plusieurs tables. Exemple d'utilisation :
                            <pre>
                            <code>
-- Sélection de données à partir d'une table
SELECT * FROM Employees;

-- Sélection de données à partir de plusieurs tables avec une jointure
SELECT Employees.FirstName, Departments.DepartmentName
FROM Employees
JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>WHERE</strong> : Filtre les résultats d'une requête en fonction d'une condition. La clause WHERE est utilisée pour spécifier des critères qui doivent être remplis pour que les enregistrements soient inclus dans les résultats de la requête. Exemple d'utilisation :
                            <pre>
                            <code>
-- Sélection de données avec une condition
SELECT * FROM Employees WHERE Age > 30;

-- Utilisation de plusieurs conditions
SELECT * FROM Employees WHERE Age > 30 AND DepartmentID = 1;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>INSERT INTO</strong> : Ajoute de nouvelles données dans une table. La clause INSERT INTO est utilisée pour insérer de nouveaux enregistrements dans une table. Vous pouvez spécifier les colonnes et les valeurs à insérer. Exemple d'utilisation :
                            <pre>
                            <code>
-- Insertion d'un nouvel enregistrement
INSERT INTO Employees (FirstName, LastName, Age, DepartmentID)
VALUES ('John', 'Doe', 28, 1);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>UPDATE</strong> : Modifie des enregistrements existants dans une table. La clause UPDATE est utilisée pour mettre à jour les valeurs des colonnes dans les enregistrements existants. Elle est souvent utilisée avec la clause WHERE pour spécifier les enregistrements à mettre à jour. Exemple d'utilisation :
                            <pre>
                            <code>
-- Mise à jour d'un enregistrement
UPDATE Employees
SET Age = 29
WHERE EmployeeID = 1;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>DELETE</strong> : Supprime des enregistrements dans une table. La clause DELETE est utilisée pour supprimer des enregistrements d'une table. Elle est souvent utilisée avec la clause WHERE pour spécifier les enregistrements à supprimer. Exemple d'utilisation :
                            <pre>
                            <code>
-- Suppression d'un enregistrement
DELETE FROM Employees
WHERE EmployeeID = 1;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ORDER BY</strong> : Trie les résultats d'une requête selon une ou plusieurs colonnes. La clause ORDER BY est utilisée pour trier les résultats d'une requête SQL par ordre croissant (ASC) ou décroissant (DESC). Exemple d'utilisation :
                            <pre>
                            <code>
-- Tri des résultats par ordre croissant
SELECT * FROM Employees
ORDER BY LastName ASC;

-- Tri des résultats par ordre décroissant
SELECT * FROM Employees
ORDER BY LastName DESC;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>GROUP BY</strong> : Regroupe les résultats selon une ou plusieurs colonnes pour appliquer des fonctions d'agrégation. La clause GROUP BY est utilisée pour regrouper les enregistrements ayant des valeurs identiques dans des colonnes spécifiées. Elle est souvent utilisée avec des fonctions d'agrégation comme COUNT, SUM, AVG, etc. Exemple d'utilisation :
                            <pre>
                            <code>
-- Regroupement des résultats et comptage des employés par département
SELECT DepartmentID, COUNT(*) as EmployeeCount
FROM Employees
GROUP BY DepartmentID;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>HAVING</strong> : Filtre les résultats d'un regroupement de données après l'utilisation de GROUP BY. La clause HAVING est utilisée pour spécifier des conditions sur les groupes créés par la clause GROUP BY. Exemple d'utilisation :
                            <pre>
                            <code>
-- Filtrage des départements ayant plus de 5 employés
SELECT DepartmentID, COUNT(*) as EmployeeCount
FROM Employees
GROUP BY DepartmentID
HAVING COUNT(*) > 5;
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Fonctions d'Agrégation -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#aggregationFunctionsSection" aria-expanded="false" aria-controls="aggregationFunctionsSection">
                    Fonctions d'Agrégation
                </button>
            </h2>
            <div id="aggregationFunctionsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>COUNT()</strong> : Compte le nombre d'enregistrements. La fonction <code>COUNT()</code> est utilisée pour retourner le nombre total de lignes dans une table ou le nombre de valeurs non nulles dans une colonne spécifique. Elle est souvent utilisée dans les requêtes SQL pour obtenir des statistiques sur les données. Exemple d'utilisation :
                            <pre>
                            <code>
-- Compter le nombre total d'employés
SELECT COUNT(*) FROM Employees;

-- Compter le nombre d'employés dans un département spécifique
SELECT COUNT(*) FROM Employees WHERE DepartmentID = 1;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>SUM()</strong> : Calcule la somme des valeurs d'une colonne numérique. La fonction <code>SUM()</code> est utilisée pour additionner toutes les valeurs d'une colonne numérique dans une table. Elle est utile pour obtenir des totaux, comme le total des ventes ou le total des salaires. Exemple d'utilisation :
                            <pre>
                            <code>
-- Calculer le total des salaires des employés
SELECT SUM(Salary) FROM Employees;

-- Calculer le total des ventes pour un produit spécifique
SELECT SUM(SalesAmount) FROM Sales WHERE ProductID = 1;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>AVG()</strong> : Calcule la moyenne des valeurs d'une colonne numérique. La fonction <code>AVG()</code> est utilisée pour calculer la moyenne des valeurs d'une colonne numérique dans une table. Elle est souvent utilisée pour obtenir des statistiques moyennes, comme la moyenne des salaires ou la moyenne des notes. Exemple d'utilisation :
                            <pre>
                            <code>
-- Calculer la moyenne des salaires des employés
SELECT AVG(Salary) FROM Employees;

-- Calculer la moyenne des notes des étudiants
SELECT AVG(Grade) FROM Students;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>MIN()</strong> : Renvoie la plus petite valeur d'une colonne. La fonction <code>MIN()</code> est utilisée pour trouver la valeur minimale dans une colonne spécifique. Elle est utile pour obtenir des valeurs minimales, comme le salaire le plus bas ou la date la plus ancienne. Exemple d'utilisation :
                            <pre>
                            <code>
-- Trouver le salaire le plus bas des employés
SELECT MIN(Salary) FROM Employees;

-- Trouver la date la plus ancienne dans les enregistrements de ventes
SELECT MIN(SaleDate) FROM Sales;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>MAX()</strong> : Renvoie la plus grande valeur d'une colonne. La fonction <code>MAX()</code> est utilisée pour trouver la valeur maximale dans une colonne spécifique. Elle est utile pour obtenir des valeurs maximales, comme le salaire le plus élevé ou la date la plus récente. Exemple d'utilisation :
                            <pre>
                            <code>
-- Trouver le salaire le plus élevé des employés
SELECT MAX(Salary) FROM Employees;

-- Trouver la date la plus récente dans les enregistrements de ventes
SELECT MAX(SaleDate) FROM Sales;
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Jointures (JOINs) -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#joinsSection" aria-expanded="false" aria-controls="joinsSection">
                    Jointures (JOINs)
                </button>
            </h2>
            <div id="joinsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>INNER JOIN</strong> : Combine des lignes de deux tables lorsqu'il y a une correspondance entre les colonnes des deux tables. La clause <code>INNER JOIN</code> est utilisée pour retourner les enregistrements qui ont des valeurs correspondantes dans les deux tables. Elle est couramment utilisée pour relier des tables sur une clé étrangère. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de INNER JOIN
SELECT Employees.Name, Departments.DepartmentName
FROM Employees
INNER JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>LEFT JOIN</strong> : Retourne toutes les lignes de la table de gauche, et les lignes correspondantes de la table de droite. Si aucune correspondance n'est trouvée, les valeurs de la table de droite sont NULL. La clause <code>LEFT JOIN</code> est utilisée pour inclure toutes les lignes de la table de gauche, même si elles n'ont pas de correspondance dans la table de droite. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de LEFT JOIN
SELECT Employees.Name, Departments.DepartmentName
FROM Employees
LEFT JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>RIGHT JOIN</strong> : Retourne toutes les lignes de la table de droite, et les lignes correspondantes de la table de gauche. Si aucune correspondance n'est trouvée, les valeurs de la table de gauche sont NULL. La clause <code>RIGHT JOIN</code> est utilisée pour inclure toutes les lignes de la table de droite, même si elles n'ont pas de correspondance dans la table de gauche. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de RIGHT JOIN
SELECT Employees.Name, Departments.DepartmentName
FROM Employees
RIGHT JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>FULL OUTER JOIN</strong> : Retourne toutes les lignes lorsqu'il y a une correspondance dans l'une ou l'autre des tables. Les valeurs non correspondantes sont remplies avec NULL. La clause <code>FULL OUTER JOIN</code> est utilisée pour inclure toutes les lignes des deux tables, même si elles n'ont pas de correspondance dans l'autre table. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de FULL OUTER JOIN
SELECT Employees.Name, Departments.DepartmentName
FROM Employees
FULL OUTER JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>CROSS JOIN</strong> : Produit cartésien des deux tables, ce qui signifie qu'il retourne toutes les combinaisons possibles entre les lignes des deux tables. La clause <code>CROSS JOIN</code> est utilisée pour retourner le produit cartésien des deux tables, ce qui peut entraîner un grand nombre de lignes si les tables sont grandes. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de CROSS JOIN
SELECT Employees.Name, Departments.DepartmentName
FROM Employees
CROSS JOIN Departments;
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Contraintes -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#constraintsSection" aria-expanded="false" aria-controls="constraintsSection">
                    Contraintes
                </button>
            </h2>
            <div id="constraintsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>PRIMARY KEY</strong> : Identifie de manière unique chaque enregistrement dans une table. Une table ne peut avoir qu'une seule clé primaire. La clé primaire est utilisée pour garantir l'unicité des enregistrements et pour établir des relations entre les tables. Exemple d'utilisation :
                            <pre>
                            <code>
-- Définir une clé primaire sur la colonne 'ID' de la table 'Employees'
CREATE TABLE Employees (
    ID INT PRIMARY KEY,
    Name NVARCHAR(100),
    DepartmentID INT
);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>FOREIGN KEY</strong> : Empêche des actions qui détruiraient des liens entre tables. C'est une clé dans une table qui fait référence à la clé primaire d'une autre table. Les clés étrangères sont utilisées pour maintenir l'intégrité référentielle entre les tables. Exemple d'utilisation :
                            <pre>
                            <code>
-- Définir une clé étrangère sur la colonne 'DepartmentID' de la table 'Employees' qui référence la colonne 'ID' de la table 'Departments'
CREATE TABLE Departments (
    ID INT PRIMARY KEY,
    DepartmentName NVARCHAR(100)
);

CREATE TABLE Employees (
    ID INT PRIMARY KEY,
    Name NVARCHAR(100),
    DepartmentID INT,
    FOREIGN KEY (DepartmentID) REFERENCES Departments(ID)
);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>NOT NULL</strong> : Empêche un champ d'accepter des valeurs NULL. La contrainte <code>NOT NULL</code> est utilisée pour garantir qu'une colonne ne peut pas avoir de valeur NULL, ce qui signifie que chaque enregistrement doit avoir une valeur pour cette colonne. Exemple d'utilisation :
                            <pre>
                            <code>
-- Définir la colonne 'Name' comme NOT NULL dans la table 'Employees'
CREATE TABLE Employees (
    ID INT PRIMARY KEY,
    Name NVARCHAR(100) NOT NULL,
    DepartmentID INT
);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>UNIQUE</strong> : Garantit que toutes les valeurs d'une colonne sont uniques. La contrainte <code>UNIQUE</code> est utilisée pour s'assurer qu'aucune valeur dupliquée n'est insérée dans une colonne spécifique. Exemple d'utilisation :
                            <pre>
                            <code>
-- Définir la colonne 'Email' comme UNIQUE dans la table 'Employees'
CREATE TABLE Employees (
    ID INT PRIMARY KEY,
    Name NVARCHAR(100),
    Email NVARCHAR(100) UNIQUE,
    DepartmentID INT
);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>CHECK</strong> : Définit une condition qui doit être vraie pour toutes les valeurs d'une colonne. La contrainte <code>CHECK</code> est utilisée pour imposer une condition sur les valeurs d'une colonne, garantissant que seules les valeurs qui satisfont cette condition sont autorisées. Exemple d'utilisation :
                            <pre>
                            <code>
-- Définir une contrainte CHECK sur la colonne 'Age' pour s'assurer que les valeurs sont supérieures ou égales à 18
CREATE TABLE Employees (
    ID INT PRIMARY KEY,
    Name NVARCHAR(100),
    Age INT CHECK (Age >= 18),
    DepartmentID INT
);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>DEFAULT</strong> : Définit une valeur par défaut pour une colonne si aucune valeur n'est spécifiée. La contrainte <code>DEFAULT</code> est utilisée pour attribuer une valeur par défaut à une colonne lorsque aucune valeur n'est fournie lors de l'insertion d'un enregistrement. Exemple d'utilisation :
                            <pre>
                            <code>
-- Définir une valeur par défaut pour la colonne 'HireDate' dans la table 'Employees'
CREATE TABLE Employees (
    ID INT PRIMARY KEY,
    Name NVARCHAR(100),
    HireDate DATE DEFAULT GETDATE(),
    DepartmentID INT
);
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Fonctions Avancées -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#advancedFunctionsSection" aria-expanded="false" aria-controls="advancedFunctionsSection">
                    Fonctions Avancées
                </button>
            </h2>
            <div id="advancedFunctionsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>COALESCE()</strong> : Retourne la première valeur non NULL parmi une liste d'arguments. La fonction <code>COALESCE()</code> est utilisée pour gérer les valeurs NULL en retournant la première valeur non NULL trouvée dans une liste d'expressions. Elle est souvent utilisée pour fournir des valeurs par défaut. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de COALESCE pour retourner la première valeur non NULL
SELECT COALESCE(NULL, 'Valeur par défaut', 'Autre valeur') AS Result;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>CASE</strong> : Permet d'effectuer des instructions conditionnelles dans les requêtes SQL. La clause <code>CASE</code> est utilisée pour ajouter une logique conditionnelle dans les requêtes SQL, permettant de retourner des valeurs différentes en fonction des conditions spécifiées. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de CASE pour retourner des valeurs conditionnelles
SELECT Name,
        CASE
            WHEN Age &lt; 18 THEN 'Mineur'
            WHEN Age &gt;= 18 THEN 'Adulte'
            ELSE 'Inconnu'
        END AS Statut
FROM Employees;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>CAST()</strong> : Convertit une expression d'un type de donnée à un autre. La fonction <code>CAST()</code> est utilisée pour convertir une expression d'un type de donnée à un autre, ce qui est utile pour les opérations nécessitant des types de données spécifiques. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de CAST pour convertir un entier en chaîne de caractères
SELECT CAST(123 AS NVARCHAR(10)) AS StringValue;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>EXISTS</strong> : Vérifie si un sous-ensemble de données existe et retourne TRUE ou FALSE. La clause <code>EXISTS</code> est utilisée pour vérifier l'existence de lignes dans un sous-ensemble de données, souvent dans des sous-requêtes, et retourne TRUE si le sous-ensemble contient des lignes. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de EXISTS pour vérifier l'existence de lignes
SELECT Name
FROM Employees
WHERE EXISTS (SELECT 1 FROM Departments WHERE Departments.ID = Employees.DepartmentID);
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>SUBSTRING()</strong> : Extrait une portion d'une chaîne de caractères. La fonction <code>SUBSTRING()</code> est utilisée pour extraire une sous-chaîne d'une chaîne de caractères, en spécifiant la position de départ et la longueur de la sous-chaîne. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de SUBSTRING pour extraire une sous-chaîne
SELECT SUBSTRING('Hello, World!', 1, 5) AS SubStringValue;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ROUND()</strong> : Arrondit une valeur numérique à un nombre de décimales spécifié. La fonction <code>ROUND()</code> est utilisée pour arrondir une valeur numérique à un nombre spécifié de décimales, ce qui est utile pour les calculs financiers et autres opérations nécessitant une précision spécifique. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de ROUND pour arrondir une valeur numérique
SELECT ROUND(123.4567, 2) AS RoundedValue;
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Gestion des Transactions -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#transactionsSection" aria-expanded="false" aria-controls="transactionsSection">
                    Gestion des Transactions
                </button>
            </h2>
            <div id="transactionsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>BEGIN TRANSACTION</strong> : Démarre une nouvelle transaction. La commande <code>BEGIN TRANSACTION</code> est utilisée pour indiquer le début d'une transaction explicite. Une transaction permet de regrouper plusieurs opérations SQL en une seule unité de travail, garantissant que toutes les opérations sont exécutées avec succès ou qu'aucune d'entre elles n'est appliquée en cas d'échec. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de BEGIN TRANSACTION
BEGIN TRANSACTION;
-- Opérations SQL
UPDATE Accounts SET Balance = Balance - 100 WHERE AccountID = 1;
UPDATE Accounts SET Balance = Balance + 100 WHERE AccountID = 2;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>COMMIT</strong> : Valide les modifications effectuées dans une transaction et les rend permanentes. La commande <code>COMMIT</code> est utilisée pour valider toutes les opérations effectuées dans la transaction en cours, rendant les modifications permanentes dans la base de données. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de COMMIT
BEGIN TRANSACTION;
-- Opérations SQL
UPDATE Accounts SET Balance = Balance - 100 WHERE AccountID = 1;
UPDATE Accounts SET Balance = Balance + 100 WHERE AccountID = 2;
-- Valider les modifications
COMMIT;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>ROLLBACK</strong> : Annule toutes les modifications effectuées dans la transaction en cours. La commande <code>ROLLBACK</code> est utilisée pour annuler toutes les opérations effectuées dans la transaction en cours, restaurant la base de données à son état initial avant le début de la transaction. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de ROLLBACK
BEGIN TRANSACTION;
-- Opérations SQL
UPDATE Accounts SET Balance = Balance - 100 WHERE AccountID = 1;
UPDATE Accounts SET Balance = Balance + 100 WHERE AccountID = 2;
-- Annuler les modifications en cas d'erreur
ROLLBACK;
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>SAVEPOINT</strong> : Définit un point de sauvegarde dans une transaction qui peut être utilisé pour effectuer un rollback partiel. La commande <code>SAVEPOINT</code> est utilisée pour créer un point de sauvegarde à l'intérieur d'une transaction, permettant de revenir à cet état spécifique sans annuler toute la transaction. Exemple d'utilisation :
                            <pre>
                            <code>
-- Exemple d'utilisation de SAVEPOINT
BEGIN TRANSACTION;
-- Opérations SQL
UPDATE Accounts SET Balance = Balance - 100 WHERE AccountID = 1;
SAVEPOINT BeforeCredit;
UPDATE Accounts SET Balance = Balance + 100 WHERE AccountID = 2;
-- Annuler les modifications jusqu'au point de sauvegarde
ROLLBACK TO SAVEPOINT BeforeCredit;
-- Valider les modifications restantes
COMMIT;
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire Blazor Web App - Program.cs avec Entity Framework Core</h1>

    <div class="accordion">
        <!-- Section Initialisation de l'Application -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#appInitializationSection" aria-expanded="false" aria-controls="appInitializationSection">
                    Initialisation de l'Application
                </button>
            </h2>
            <div id="appInitializationSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>WebApplication.CreateBuilder()</strong> : Méthode utilisée pour créer un <code>WebApplicationBuilder</code> qui configure les services, l'hébergement et l'infrastructure de l'application. Cette méthode initialise un nouveau constructeur d'application web avec les paramètres par défaut, permettant de configurer les services et le pipeline de requêtes. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de création d'un WebApplicationBuilder en C#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRazorComponents();
var app = builder.Build();
app.Run();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>builder.Services</strong> : Propriété qui permet de configurer les services utilisés par l'application (ex: injection de dépendances, authentification). Cette propriété expose un <code>IServiceCollection</code> permettant d'ajouter des services au conteneur d'injection de dépendances. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de configuration des services en C#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRazorComponents();
builder.Services.AddAuthentication();
var app = builder.Build();
app.Run();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>AddRazorComponents()</strong> : Permet d'ajouter le support des composants Blazor dans une application. Cette méthode configure les services nécessaires pour utiliser les composants Razor dans une application Blazor. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'ajout de support pour les composants Razor en C#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRazorComponents();
var app = builder.Build();
app.Run();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>AddServerSideBlazor()</strong> : Ajoute le support pour Blazor côté serveur dans une application. Cette méthode configure les services nécessaires pour exécuter des composants Blazor sur le serveur et les rendre interactifs via SignalR. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'ajout de support pour Blazor Server en C#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddServerSideBlazor();
var app = builder.Build();
app.MapBlazorHub();
app.Run();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>builder.Build()</strong> : Construit une instance de <code>WebApplication</code> qui sera exécutée. Cette méthode compile la configuration de l'application et prépare le pipeline de requêtes pour le traitement des requêtes HTTP. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de construction d'une instance de WebApplication en C#
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.Run();
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Configuration des Services -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#servicesConfigurationSection" aria-expanded="false" aria-controls="servicesConfigurationSection">
                    Configuration des Services (avec Entity Framework Core)
                </button>
            </h2>
            <div id="servicesConfigurationSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>builder.Services.AddSingleton()</strong> : Ajoute un service en tant que singleton. Le même objet sera partagé entre toutes les requêtes. Cette méthode est utilisée pour enregistrer un service avec une durée de vie unique, ce qui signifie qu'une seule instance du service sera créée et utilisée tout au long de la durée de vie de l'application. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'ajout d'un service singleton en C#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddSingleton&lt;IMyService, MyService&gt;();
var app = builder.Build();
app.Run();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>builder.Services.AddTransient()</strong> : Ajoute un service en tant que transient, créant une nouvelle instance pour chaque requête. Cette méthode est utilisée pour enregistrer un service avec une durée de vie transitoire, ce qui signifie qu'une nouvelle instance du service sera créée chaque fois qu'il est demandé. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'ajout d'un service transient en C#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient&lt;IMyService, MyService&gt;();
var app = builder.Build();
app.Run();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>builder.Services.AddScoped()</strong> : Ajoute un service avec une durée de vie "scoped", une instance par session utilisateur. Cette méthode est utilisée pour enregistrer un service avec une durée de vie limitée à la portée d'une requête ou d'une session, ce qui signifie qu'une nouvelle instance du service sera créée pour chaque session utilisateur. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'ajout d'un service scoped en C#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddScoped&lt;IMyService, MyService&gt;();
var app = builder.Build();
app.Run();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>builder.Services.AddHttpClient()</strong> : Permet d'enregistrer et de configurer un service HTTP client pour les requêtes HTTP externes. Cette méthode est utilisée pour configurer des instances de <code>HttpClient</code> avec des paramètres spécifiques, comme les en-têtes par défaut, les délais d'attente, et les gestionnaires de messages. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'ajout d'un service HttpClient en C#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddHttpClient&lt;IMyService, MyService&gt;(client =>
{
    client.BaseAddress = new Uri("https://api.example.com/");
    client.DefaultRequestHeaders.Add("Accept", "application/json");
});
var app = builder.Build();
app.Run();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>builder.Services.AddAuthorizationCore()</strong> : Ajoute les services d'autorisation dans une application Blazor, généralement utilisés pour gérer l'accès à certaines pages ou composants. Cette méthode est utilisée pour configurer les services d'autorisation de base nécessaires pour contrôler l'accès aux ressources en fonction des rôles ou des revendications des utilisateurs. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'ajout des services d'autorisation en C#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddAuthorizationCore();
var app = builder.Build();
app.Run();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>builder.Services.AddDbContext&lt;TContext&gt;()</strong> : Ajoute et configure un service de contexte de base de données Entity Framework Core. Cette méthode est utilisée pour enregistrer un contexte de base de données avec des options spécifiques, comme le fournisseur de base de données et la chaîne de connexion. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple d'ajout d'un contexte de base de données en C#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext&lt;MyDbContext&gt;(options =>
    options.UseSqlServer("Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;"));
var app = builder.Build();
app.Run();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>UseSqlServer()</strong> : Configure l'utilisation de SQL Server comme fournisseur de base de données pour Entity Framework Core. Cette méthode est utilisée pour spécifier que SQL Server sera utilisé comme base de données pour le contexte Entity Framework Core. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de configuration de SQL Server en C#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext&lt;MyDbContext&gt;(options =>
    options.UseSqlServer("Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;"));
var app = builder.Build();
app.Run();
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>UseSqlite()</strong> : Configure SQLite comme fournisseur de base de données dans une application légère. Cette méthode est utilisée pour spécifier que SQLite sera utilisé comme base de données pour le contexte Entity Framework Core. Exemple d'utilisation :
                            <pre>
                            <code>
// Exemple de configuration de SQLite en C#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext&lt;MyDbContext&gt;(options =>
    options.UseSqlite("Data Source=mydatabase.db"));
var app = builder.Build();
app.Run();
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Gestion des Endpoints -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#endpointsManagementSection" aria-expanded="false" aria-controls="endpointsManagementSection">
                    Gestion des Endpoints
                </button>
            </h2>
            <div id="endpointsManagementSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>app.MapBlazorHub()</strong> : Configure les routes pour la communication en temps réel via SignalR pour les composants Blazor. Cela permet aux composants Blazor de communiquer avec le serveur en utilisant SignalR, ce qui est essentiel pour les applications Blazor Server. Exemple :
                            <pre>
                            <code>
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapBlazorHub();
app.MapFallbackToPage("/_Host");

app.Run();
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>app.MapFallbackToPage()</strong> : Définit une page par défaut (fallback) si aucune route ne correspond à la requête entrante. Cela est utile pour gérer les erreurs 404 et rediriger les utilisateurs vers une page spécifique. Exemple :
                            <pre>
                            <code>
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapBlazorHub();
app.MapFallbackToPage("/_Host");

app.Run();
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>app.MapControllers()</strong> : Active le routage pour les contrôleurs MVC ou API dans une application Blazor Server. Cela permet de définir des routes pour les actions des contrôleurs. Exemple :
                            <pre>
                            <code>
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.UseRouting();
app.MapControllers();

app.Run();
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>app.UseRouting()</strong> : Active le routage dans l'application pour la gestion des requêtes entrantes. Cela est nécessaire pour utiliser les middlewares de routage et définir les routes de l'application. Exemple :
                            <pre>
                            <code>
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.UseRouting();

app.Run();
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>app.UseEndpoints()</strong> : Utilisé pour configurer manuellement les points de terminaison des routes dans l'application. Cela permet de définir les routes et les points de terminaison pour les requêtes HTTP. Exemple :
                            <pre>
                            <code>
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.UseRouting();
app.UseEndpoints(endpoints =>
{
    endpoints.MapBlazorHub();
    endpoints.MapFallbackToPage("/_Host");
    endpoints.MapControllers();
});

app.Run();
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Middleware et Pipeline HTTP -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#middlewareSection" aria-expanded="false" aria-controls="middlewareSection">
                    Middleware et Pipeline HTTP
                </button>
            </h2>
            <div id="middlewareSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>app.UseMiddleware&lt;T&gt;()</strong> : Ajoute un middleware personnalisé au pipeline HTTP de l'application. Les middlewares sont des composants qui gèrent les requêtes et les réponses HTTP. Exemple :
                            <pre>
                            <code>
public class CustomMiddleware
{
    private readonly RequestDelegate _next;

    public CustomMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Logique du middleware
        await context.Response.WriteAsync("Middleware personnalisé exécuté.");
        await _next(context);
    }
}

// Dans la méthode Configure de Startup.cs
app.UseMiddleware&lt;CustomMiddleware&gt;();
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>app.UseAuthentication()</strong> : Active l'authentification dans l'application pour vérifier l'identité des utilisateurs. Cela est essentiel pour sécuriser les applications et restreindre l'accès aux ressources. Exemple :
                            <pre>
                            <code>
// Dans la méthode Configure de Startup.cs
app.UseAuthentication();
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>app.UseAuthorization()</strong> : Active l'autorisation, qui permet de contrôler l'accès aux ressources en fonction de l'authentification de l'utilisateur. Cela fonctionne en conjonction avec l'authentification pour appliquer des règles d'accès. Exemple :
                            <pre>
                            <code>
// Dans la méthode Configure de Startup.cs
app.UseAuthorization();
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>app.UseStaticFiles()</strong> : Permet la gestion des fichiers statiques (HTML, CSS, JS) dans l'application. Cela est nécessaire pour servir des fichiers statiques aux clients. Exemple :
                            <pre>
                            <code>
// Dans la méthode Configure de Startup.cs
app.UseStaticFiles();
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>app.UseHttpsRedirection()</strong> : Redirige automatiquement toutes les requêtes HTTP vers HTTPS pour sécuriser les communications. Cela est important pour garantir que toutes les données échangées entre le client et le serveur sont chiffrées. Exemple :
                            <pre>
                            <code>
// Dans la méthode Configure de Startup.cs
app.UseHttpsRedirection();
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Migration de la Base de Données -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#dbMigrationSection" aria-expanded="false" aria-controls="dbMigrationSection">
                    Migration de la Base de Données (Entity Framework Core)
                </button>
            </h2>
            <div id="dbMigrationSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Database.EnsureCreated()</strong> : Vérifie si la base de données est créée et la crée si elle n'existe pas, mais n'applique pas de migrations. Cela est utile pour les scénarios de développement ou de test où vous souhaitez rapidement initialiser une base de données. Exemple :
                            <pre>
                            <code>
using (var context = new MyDbContext())
{
    context.Database.EnsureCreated();
}
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Database.Migrate()</strong> : Applique toutes les migrations en attente pour s'assurer que la base de données est à jour par rapport au modèle Entity Framework. Cela est essentiel pour maintenir la synchronisation entre le modèle de données et la base de données. Exemple :
                            <pre>
                            <code>
using (var context = new MyDbContext())
{
    context.Database.Migrate();
}
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>dotnet ef migrations add &lt;NomMigration&gt;</strong> : Commande CLI utilisée pour ajouter une migration à l'application qui décrit les modifications de la structure de la base de données. Cela génère un fichier de migration qui peut être appliqué à la base de données. Exemple :
                            <pre>
                            <code>
dotnet ef migrations add InitialCreate
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>dotnet ef database update</strong> : Commande CLI qui applique les migrations à la base de données. Cela met à jour la base de données pour qu'elle corresponde au modèle de données actuel. Exemple :
                            <pre>
                            <code>
dotnet ef database update
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Exécution de l'Application -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#runAppSection" aria-expanded="false" aria-controls="runAppSection">
                    Exécution de l'Application
                </button>
            </h2>
            <div id="runAppSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>app.Run()</strong> : Méthode utilisée pour démarrer l'application Web Blazor après la configuration de tous les services, middleware et endpoints. Cette méthode bloque le thread d'appel et commence à écouter les requêtes HTTP. Exemple :
                            <pre>
                            <code>
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.UseRouting();
app.UseEndpoints(endpoints =>
{
    endpoints.MapBlazorHub();
    endpoints.MapFallbackToPage("/_Host");
});

app.Run();
                            </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Environment</strong> : Variable utilisée pour définir l'environnement dans lequel l'application s'exécute (par exemple, Développement, Production). Cela permet de configurer l'application différemment selon l'environnement. Exemple :
                            <pre>
                            <code>
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/Error");
    app.UseHsts();
}

app.Run();
                            </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire GitHub</h1>

    <div class="accordion">
        <!-- Section GitHub Basics -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#gitHubBasicsSection" aria-expanded="false" aria-controls="gitHubBasicsSection">
                    Concepts de Base de GitHub
                </button>
            </h2>
            <div id="gitHubBasicsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Repository (Repo)</strong> : Espace ou projet où votre code et historique sont stockés sur GitHub. Un dépôt contient tous les fichiers de votre projet ainsi que l'historique de leurs modifications. Il permet de collaborer avec d'autres développeurs et de suivre les changements apportés au code. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'un nouveau dépôt sur GitHub
git init my-repo
cd my-repo
git remote add origin https://github.com/username/my-repo.git
git push -u origin main
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Branch</strong> : Version alternative d'un dépôt où vous pouvez développer de nouvelles fonctionnalités indépendamment de la branche principale. Les branches permettent de travailler sur différentes fonctionnalités ou corrections de bugs sans affecter le code stable de la branche principale. Exemple d'utilisation :
                            <pre>
                            <code>
// Création et basculement vers une nouvelle branche
git checkout -b new-feature
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Commit</strong> : Modification ou ensemble de modifications enregistrées dans un dépôt. Un commit capture l'état actuel des fichiers dans le dépôt et enregistre un message décrivant les changements. Exemple d'utilisation :
                            <pre>
                            <code>
// Ajout de fichiers au commit et enregistrement des modifications
git add .
git commit -m "Ajout de la nouvelle fonctionnalité"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Clone</strong> : Copier un dépôt distant sur votre machine locale. Cloner un dépôt vous permet de travailler sur une copie locale du projet et de synchroniser les changements avec le dépôt distant. Exemple d'utilisation :
                            <pre>
                            <code>
// Clonage d'un dépôt GitHub
git clone https://github.com/username/repo.git
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Fork</strong> : Copier un projet depuis un dépôt GitHub sur votre propre compte, vous permettant de modifier le code sans affecter l'original. Un fork est souvent utilisé pour contribuer à des projets open source. Exemple d'utilisation :
                            <pre>
                            <code>
// Fork d'un dépôt sur GitHub via l'interface web
// Cliquez sur le bouton "Fork" sur la page du dépôt
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Pull Request (PR)</strong> : Demande d'intégration de vos modifications dans la branche principale ou dans un autre projet. Une pull request permet de proposer des changements, de discuter de leur pertinence et de les réviser avant de les fusionner. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'une pull request sur GitHub via l'interface web
// Allez sur la page du dépôt et cliquez sur "New pull request"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Merge</strong> : Fusionner une branche dans une autre (généralement dans la branche principale). La fusion intègre les changements d'une branche dans une autre, combinant les historiques de commits. Exemple d'utilisation :
                            <pre>
                            <code>
// Fusion d'une branche dans la branche principale
git checkout main
git merge new-feature
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Git</strong> : Système de gestion de version distribué utilisé par GitHub pour suivre les changements dans le code. Git permet de gérer l'historique des modifications, de collaborer avec d'autres développeurs et de gérer différentes versions du code. Exemple d'utilisation :
                            <pre>
                            <code>
// Initialisation d'un nouveau dépôt Git
git init
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Gestion de Projet -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#projectManagementSection" aria-expanded="false" aria-controls="projectManagementSection">
                    Gestion de Projet sur GitHub
                </button>
            </h2>
            <div id="projectManagementSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Issue</strong> : Ticket créé pour signaler un bogue, demander une fonctionnalité ou poser une question. Les issues permettent de suivre les problèmes et les améliorations dans un projet. Elles peuvent être commentées, étiquetées, assignées à des développeurs et liées à des pull requests pour une meilleure gestion des tâches. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'une issue sur GitHub via l'interface web
// Allez sur la page du dépôt et cliquez sur "Issues" puis "New issue"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Milestone</strong> : Série d'issues ou de pull requests liées à une fonctionnalité ou une version spécifique. Les milestones aident à organiser et à planifier le travail en regroupant les tâches liées. Elles permettent de suivre la progression vers des objectifs spécifiques et de gérer les versions du projet. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'un milestone sur GitHub via l'interface web
// Allez sur la page du dépôt, cliquez sur "Milestones" puis "New milestone"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Labels</strong> : Étiquettes qui permettent de catégoriser les issues et les pull requests. Les labels facilitent la gestion et la recherche des tâches en ajoutant des catégories comme "bug", "enhancement", "documentation", etc. Ils aident à prioriser et à organiser le travail. Exemple d'utilisation :
                            <pre>
                            <code>
// Ajout d'un label à une issue sur GitHub via l'interface web
// Ouvrez une issue, cliquez sur "Labels" et sélectionnez les labels appropriés
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Projects</strong> : Outils de gestion de projet intégrés qui vous permettent d'organiser les tâches sous forme de tableaux Kanban. Les projets offrent une vue d'ensemble des tâches en cours, à faire et terminées. Ils aident à visualiser le flux de travail et à gérer les tâches de manière plus efficace. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'un projet sur GitHub via l'interface web
// Allez sur la page du dépôt, cliquez sur "Projects" puis "New project"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Assignees</strong> : Personnes assignées à une issue ou une pull request pour être responsables de sa résolution. Assigner des développeurs à des tâches spécifiques permet de clarifier les responsabilités et de suivre qui travaille sur quoi. Cela améliore la collaboration et la gestion des tâches. Exemple d'utilisation :
                            <pre>
                            <code>
// Assignation d'une issue à un développeur sur GitHub via l'interface web
// Ouvrez une issue, cliquez sur "Assignees" et sélectionnez le développeur approprié
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Mentions</strong> : Utiliser &#64; suivi du nom d'un utilisateur pour notifier directement cette personne dans une issue ou un commentaire. Les mentions attirent l'attention des utilisateurs concernés et facilitent la communication et la collaboration au sein de l'équipe. Exemple d'utilisation :
                            <pre>
                            <code>
// Mention d'un utilisateur dans un commentaire sur GitHub
// Tapez &#64;username dans le commentaire pour notifier l'utilisateur
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Collaboration -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collaborationSection" aria-expanded="false" aria-controls="collaborationSection">
                    Collaboration sur GitHub
                </button>
            </h2>
            <div id="collaborationSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Collaborators</strong> : Utilisateurs ayant accès à un dépôt pour contribuer directement au code. Les collaborateurs peuvent cloner le dépôt, créer des branches, soumettre des commits et ouvrir des pull requests. Ils jouent un rôle clé dans le développement collaboratif et la gestion des projets sur GitHub. Exemple d'utilisation :
                            <pre>
                            <code>
// Ajout d'un collaborateur à un dépôt sur GitHub via l'interface web
// Allez sur la page du dépôt, cliquez sur "Settings" puis "Collaborators" et ajoutez l'utilisateur
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Contributor</strong> : Personne ayant soumis une pull request ou contribué à un projet open-source. Les contributeurs peuvent être des membres de l'équipe ou des développeurs externes qui proposent des améliorations, des corrections de bugs ou de nouvelles fonctionnalités. Leur participation est essentielle pour l'évolution et l'amélioration des projets open-source. Exemple d'utilisation :
                            <pre>
                            <code>
// Contribution à un projet open-source via une pull request
// Forkez le dépôt, faites vos modifications, puis ouvrez une pull request pour proposer vos changements
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Code Review</strong> : Processus d'examen du code soumis dans une pull request avant de fusionner les modifications. La revue de code permet de détecter les erreurs, d'améliorer la qualité du code et de partager des connaissances entre les membres de l'équipe. Elle est souvent réalisée par des collaborateurs ou des mainteneurs du projet. Exemple d'utilisation :
                            <pre>
                            <code>
// Réalisation d'une revue de code sur GitHub via l'interface web
// Allez sur la pull request, cliquez sur "Files changed" et ajoutez vos commentaires et suggestions
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Blame</strong> : Fonction GitHub pour voir qui a effectué une modification spécifique dans un fichier. La commande <code>git blame</code> permet de suivre l'historique des modifications ligne par ligne, identifiant l'auteur et le commit associé. Cela aide à comprendre l'origine des changements et à attribuer la responsabilité des modifications. Exemple d'utilisation :
                            <pre>
                            <code>
// Utilisation de la commande git blame pour voir l'historique des modifications
git blame filename
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Actions GitHub</strong> : Plateforme d'intégration continue et de livraison continue (CI/CD) qui automatise les flux de travail à partir de votre dépôt GitHub. GitHub Actions permet de créer des workflows personnalisés pour compiler, tester et déployer le code automatiquement. Cela améliore l'efficacité et la fiabilité du processus de développement. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'un workflow GitHub Actions pour compiler et tester le code
// Créez un fichier .yml dans le répertoire .github/workflows de votre dépôt
name: CI

on: [push, pull_request]

jobs:
    build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up .NET
        uses: actions/setup-dotnet@v1
        with:
        dotnet-version: '5.0.x'
    - name: Build with dotnet
        run: dotnet build --configuration Release
    - name: Test with dotnet
        run: dotnet test --no-build --verbosity normal
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Wiki</strong> : Documentation collaborative pour un projet, stockée directement dans un dépôt. Le wiki permet de créer et de maintenir une documentation détaillée, accessible à tous les contributeurs. Il est souvent utilisé pour documenter les fonctionnalités, les guides d'utilisation, les processus de développement et les informations importantes sur le projet. Exemple d'utilisation :
                            <pre>
                            <code>
// Création et édition d'une page de wiki sur GitHub via l'interface web
// Allez sur la page du dépôt, cliquez sur "Wiki" puis "New Page" pour ajouter une nouvelle page de documentation
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Sécurité et Gestion de Version -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#securityVersioningSection" aria-expanded="false" aria-controls="securityVersioningSection">
                    Sécurité et Gestion de Version
                </button>
            </h2>
            <div id="securityVersioningSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>SSH Key</strong> : Clé de sécurité utilisée pour accéder à votre compte GitHub et effectuer des opérations sécurisées. Une clé SSH est composée d'une paire de clés (publique et privée). La clé publique est ajoutée à votre compte GitHub, tandis que la clé privée reste sur votre machine. Cela permet une authentification sécurisée sans avoir à entrer votre mot de passe à chaque fois. Exemple d'utilisation :
                            <pre>
                            <code>
// Génération d'une clé SSH et ajout à GitHub
ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
cat ~/.ssh/id_rsa.pub
// Copiez la clé publique et ajoutez-la à votre compte GitHub sous "Settings" > "SSH and GPG keys"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Access Token</strong> : Jeton d'accès permettant de faire des requêtes à l'API GitHub de manière sécurisée. Les tokens d'accès sont utilisés pour authentifier les applications et les scripts qui interagissent avec l'API GitHub. Ils offrent un moyen sécurisé de gérer les autorisations sans utiliser votre mot de passe GitHub. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'un token d'accès personnel sur GitHub
// Allez sur "Settings" > "Developer settings" > "Personal access tokens" > "Generate new token"
// Utilisez le token généré pour authentifier les requêtes API
curl -H "Authorization: token YOUR_ACCESS_TOKEN" https://api.github.com/user
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Version Tag</strong> : Balise utilisée pour marquer une version spécifique du code dans un dépôt. Les tags de version sont souvent utilisés pour indiquer des versions stables ou des points de référence importants dans l'historique du projet. Par exemple, un tag <code>v1.0.0</code> peut indiquer la première version stable d'un projet. Exemple d'utilisation :
                            <pre>
                            <code>
// Création et push d'un tag de version sur GitHub
git tag v1.0.0
git push origin v1.0.0
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Release</strong> : Publication d'une version stable d'un projet avec des fichiers binaires, des notes de version, et des tags. Les releases permettent de distribuer des versions spécifiques de votre projet aux utilisateurs. Elles incluent souvent des fichiers exécutables, des bibliothèques, et des informations sur les changements apportés depuis la dernière version. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'une release sur GitHub via l'interface web
// Allez sur la page du dépôt, cliquez sur "Releases" puis "Draft a new release"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Dependency Graph</strong> : Outil qui affiche les dépendances et avertit si des vulnérabilités sont détectées. Le graphe de dépendances permet de visualiser les bibliothèques et les packages dont dépend votre projet. Il aide à identifier les mises à jour nécessaires et à gérer les vulnérabilités de sécurité. Exemple d'utilisation :
                            <pre>
                            <code>
// Visualisation du graphe de dépendances sur GitHub
// Allez sur la page du dépôt, cliquez sur "Insights" puis "Dependency graph"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Branch Protection</strong> : Fonctionnalité de GitHub pour protéger une branche contre les modifications non autorisées (ex: besoin de revue avant un merge). Les règles de protection de branche peuvent inclure des exigences telles que des revues de code obligatoires, des tests de CI réussis, et des restrictions sur qui peut pousser des modifications. Exemple d'utilisation :
                            <pre>
                            <code>
// Configuration des règles de protection de branche sur GitHub
// Allez sur la page du dépôt, cliquez sur "Settings" > "Branches" > "Add rule"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>GitHub Pages</strong> : Fonctionnalité de GitHub qui permet d'héberger des pages web statiques directement depuis un dépôt. GitHub Pages est souvent utilisé pour héberger des sites de documentation, des blogs, ou des portfolios. Il prend en charge les générateurs de sites statiques comme Jekyll et permet de déployer facilement des sites web à partir de branches spécifiques de votre dépôt. Exemple d'utilisation :
                            <pre>
                            <code>
// Déploiement d'un site avec GitHub Pages
// Allez sur la page du dépôt, cliquez sur "Settings" > "Pages" et configurez la source de déploiement
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Utilisation Avancée -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#advancedUsageSection" aria-expanded="false" aria-controls="advancedUsageSection">
                    Utilisation Avancée
                </button>
            </h2>
            <div id="advancedUsageSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Webhooks</strong> : Points de connexion permettant de recevoir des notifications en temps réel lorsqu'un événement se produit dans un dépôt GitHub. Les webhooks peuvent être configurés pour déclencher des actions spécifiques, comme l'envoi de notifications, l'exécution de scripts ou l'intégration avec des services externes, en réponse à des événements tels que des commits, des pull requests ou des issues. Exemple d'utilisation :
                            <pre>
                            <code>
// Configuration d'un webhook sur GitHub via l'interface web
// Allez sur la page du dépôt, cliquez sur "Settings" > "Webhooks" > "Add webhook"
// Entrez l'URL du webhook et sélectionnez les événements à surveiller
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>API GitHub</strong> : Interface permettant d'automatiser et d'interagir avec les fonctionnalités de GitHub via des requêtes HTTP. L'API GitHub permet de gérer les dépôts, les issues, les pull requests, les utilisateurs, et bien plus encore. Elle est utilisée pour créer des intégrations personnalisées, des outils de gestion de projet et des automatisations de workflow. Exemple d'utilisation :
                            <pre>
                            <code>
// Utilisation de l'API GitHub pour lister les dépôts d'un utilisateur
curl -H "Authorization: token YOUR_ACCESS_TOKEN" https://api.github.com/user/repos
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Actions Secrets</strong> : Variables d'environnement sécurisées utilisées dans les workflows GitHub Actions pour protéger les informations sensibles. Les secrets sont chiffrés et ne sont accessibles qu'aux workflows autorisés. Ils sont utilisés pour stocker des clés API, des tokens d'accès, des mots de passe, et d'autres informations sensibles nécessaires à l'exécution des workflows. Exemple d'utilisation :
                            <pre>
                            <code>
// Ajout d'un secret dans un dépôt GitHub via l'interface web
// Allez sur la page du dépôt, cliquez sur "Settings" > "Secrets" > "New repository secret"
// Utilisez le secret dans un workflow GitHub Actions
name: CI

on: [push]

jobs:
    build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
        uses: actions/checkout@v2
    - name: Use secret
        run: echo ${{ secrets.MY_SECRET }}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Squash Merge</strong> : Fusionner une branche en un seul commit afin de maintenir un historique Git propre. Le squash merge combine tous les commits d'une branche en un seul commit avant de les fusionner dans la branche cible. Cela simplifie l'historique du projet et facilite la lecture des changements apportés. Exemple d'utilisation :
                            <pre>
                            <code>
// Réalisation d'un squash merge sur GitHub via l'interface web
// Allez sur la pull request, cliquez sur le bouton de fusion et sélectionnez "Squash and merge"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Rebase</strong> : Rejouer les commits d'une branche sur une autre, créant un historique linéaire. Le rebase permet de déplacer ou de combiner des commits, en appliquant les changements d'une branche sur une autre comme s'ils avaient été créés à partir de cette branche. Cela aide à maintenir un historique de commits propre et linéaire. Exemple d'utilisation :
                            <pre>
                            <code>
// Rebase d'une branche sur la branche principale
git checkout feature-branch
git rebase main
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>GitHub CLI</strong> : Interface en ligne de commande permettant d'interagir avec GitHub directement depuis un terminal. La GitHub CLI (Command Line Interface) offre des commandes pour gérer les dépôts, les issues, les pull requests, les actions, et bien plus encore. Elle facilite l'automatisation des tâches et l'intégration de GitHub dans les scripts et les workflows de développement. Exemple d'utilisation :
                            <pre>
                            <code>
// Installation de GitHub CLI et création d'une issue
gh issue create --title "Bug report" --body "Description du bug"
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
<p>&nbsp;</p>
<div class="container mt-5">
    <h1 class="text-center text-primary mb-4">Vocabulaire Azure</h1>

    <div class="accordion">
        <!-- Section Azure Concepts de Base -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#azureBasicsSection" aria-expanded="false" aria-controls="azureBasicsSection">
                    Concepts de Base d'Azure
                </button>
            </h2>
            <div id="azureBasicsSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Azure App Service</strong> : Service permettant de créer et d'héberger des applications web, des API, et des applications mobiles dans un environnement cloud sécurisé et scalable. Azure App Service prend en charge plusieurs langages de programmation, notamment .NET, Java, Node.js, PHP, et Python. Il offre des fonctionnalités telles que le déploiement continu, l'intégration avec GitHub, la mise à l'échelle automatique, et la gestion des certificats SSL. Exemple d'utilisation :
                            <pre>
                            <code>
// Déploiement d'une application web ASP.NET Core sur Azure App Service
az webapp up --name mywebapp --resource-group myResourceGroup --plan myAppServicePlan
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Virtual Machines</strong> : Machines virtuelles permettant d'exécuter des systèmes d'exploitation et des applications dans le cloud sans gestion matérielle directe. Azure Virtual Machines offrent une flexibilité totale en termes de configuration matérielle et logicielle, permettant de choisir le système d'exploitation, la taille de la machine, et les options de stockage. Elles sont idéales pour les charges de travail nécessitant un contrôle granulaire des ressources. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'une machine virtuelle Windows Server sur Azure
az vm create --resource-group myResourceGroup --name myVM --image Win2019Datacenter --admin-username azureuser --admin-password myPassword123!
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Storage</strong> : Service de stockage scalable pour gérer les blobs, les files d'attente, les fichiers et les tables dans le cloud. Azure Storage propose plusieurs types de stockage, notamment Blob Storage pour les objets non structurés, Queue Storage pour la gestion des files d'attente de messages, File Storage pour les partages de fichiers accessibles via SMB, et Table Storage pour les données NoSQL. Il offre une haute disponibilité, une durabilité des données, et des options de redondance géographique. Exemple d'utilisation :
                            <pre>
                            <code>
// Téléchargement d'un fichier dans Azure Blob Storage
az storage blob upload --account-name myStorageAccount --container-name myContainer --name myBlob --file myFile.txt
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Active Directory (Azure AD)</strong> : Service de gestion des identités et des accès qui aide les entreprises à protéger l'accès aux applications et ressources. Azure AD fournit des fonctionnalités telles que l'authentification unique (SSO), la gestion des utilisateurs et des groupes, l'intégration avec des applications SaaS, et la protection des identités avec des politiques de sécurité avancées. Il permet également l'intégration avec les annuaires locaux via Azure AD Connect. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'un utilisateur dans Azure AD
az ad user create --display-name "John Doe" --user-principal-name johndoe@mydomain.com --password MyPassword123!
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Functions</strong> : Plateforme serverless qui permet de créer des applications et des services à l'aide d'une architecture événementielle, en réponse à des événements déclenchés. Azure Functions supporte plusieurs langages de programmation, y compris C#, JavaScript, Python, et Java. Les fonctions peuvent être déclenchées par divers événements, tels que des modifications de données dans Azure Storage, des messages dans Azure Service Bus, ou des requêtes HTTP. Elles permettent de construire des applications scalables sans gérer l'infrastructure sous-jacente. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'une fonction Azure en C#
[FunctionName("HttpTriggerCSharp")]
public static async Task&lt;IActionResult&gt; Run(
    [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
    ILogger log)
{
    log.LogInformation("C# HTTP trigger function processed a request.");
    string name = req.Query["name"];
    return name != null
        ? (ActionResult)new OkObjectResult($"Hello, {name}")
        : new BadRequestObjectResult("Please pass a name on the query string or in the request body");
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Services de Base Azure -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#azureServicesSection" aria-expanded="false" aria-controls="azureServicesSection">
                    Services de Base Azure
                </button>
            </h2>
            <div id="azureServicesSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Azure SQL Database</strong> : Base de données relationnelle managée qui permet de créer, gérer et mettre à l'échelle des bases de données SQL dans le cloud. Azure SQL Database offre des fonctionnalités telles que la haute disponibilité, la récupération d'urgence, la sauvegarde automatique, et la mise à l'échelle élastique. Elle prend en charge les requêtes SQL, les transactions ACID, et l'intégration avec d'autres services Azure pour l'analyse et le reporting. Exemple d'utilisation :
                            <pre>
                            <code>
// Connexion à une base de données Azure SQL en C#
string connectionString = "Server=tcp:myserver.database.windows.net,1433;Initial Catalog=mydatabase;Persist Security Info=False;User ID=myuser;Password=mypassword;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;";
using (SqlConnection connection = new SqlConnection(connectionString))
{
    connection.Open();
    SqlCommand command = new SqlCommand("SELECT * FROM mytable", connection);
    SqlDataReader reader = command.ExecuteReader();
    while (reader.Read())
    {
        Console.WriteLine($"{reader["ColumnName"]}");
    }
}
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Kubernetes Service (AKS)</strong> : Service de gestion des conteneurs qui permet de déployer, gérer et faire évoluer des applications conteneurisées en utilisant Kubernetes. AKS simplifie la gestion des clusters Kubernetes en automatisant des tâches telles que la mise à jour, la surveillance, et la mise à l'échelle. Il offre une intégration avec d'autres services Azure, comme Azure DevOps pour les pipelines CI/CD et Azure Monitor pour la surveillance des performances. Exemple d'utilisation :
                            <pre>
                            <code>
// Déploiement d'un cluster AKS
az aks create --resource-group myResourceGroup --name myAKSCluster --node-count 1 --enable-addons monitoring --generate-ssh-keys
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Cosmos DB</strong> : Base de données NoSQL distribuée mondialement pour la gestion de grandes quantités de données avec haute disponibilité et latence faible. Azure Cosmos DB prend en charge plusieurs modèles de données, y compris les documents, les graphes, les colonnes larges, et les clés-valeurs. Elle offre des garanties de performance, une réplication multi-région, et des options de cohérence ajustables pour répondre aux besoins spécifiques des applications. Exemple d'utilisation :
                            <pre>
                            <code>
// Connexion à Azure Cosmos DB en C#
CosmosClient client = new CosmosClient("accountEndpoint", "accountKey");
Database database = await client.CreateDatabaseIfNotExistsAsync("myDatabase");
Container container = await database.CreateContainerIfNotExistsAsync("myContainer", "/partitionKey");
ItemResponse&lt;MyItem&gt; response = await container.CreateItemAsync(new MyItem { Id = "1", Name = "Item1" }, new PartitionKey("partitionKey"));
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure DevOps</strong> : Suite d'outils permettant de gérer le cycle de vie complet des applications, de la planification au déploiement, en passant par le développement et les tests. Azure DevOps inclut des services tels que Azure Repos pour le contrôle de version, Azure Pipelines pour l'intégration et le déploiement continus (CI/CD), Azure Boards pour la gestion des projets et des tâches, et Azure Test Plans pour les tests automatisés et manuels. Exemple d'utilisation :
                            <pre>
                            <code>
// Définition d'un pipeline CI/CD dans Azure Pipelines
trigger:
- main

pool:
    vmImage: 'ubuntu-latest'

steps:
- task: UseDotNet@2
    inputs:
    packageType: 'sdk'
    version: '5.x'
    installationPath: $(Agent.ToolsDirectory)/dotnet

- script: dotnet build --configuration Release
    displayName: 'Build project'

- script: dotnet test --no-build --verbosity normal
    displayName: 'Run tests'
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Logic Apps</strong> : Service permettant de créer des flux de travail automatisés qui intègrent des applications, des données et des systèmes au sein du cloud. Azure Logic Apps permet de concevoir des workflows visuellement en utilisant une interface graphique et de connecter facilement des services tels que Office 365, Dynamics 365, Salesforce, et bien d'autres. Il prend en charge des déclencheurs et des actions basés sur des événements pour automatiser des processus métier complexes. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'une Logic App pour envoyer un email lorsqu'un fichier est ajouté à un Blob Storage
{
    "definition": {
        "$schema": "https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#",
        "actions": {
            "Send_an_email": {
                "inputs": {
                    "body": "A new file has been added to the Blob Storage.",
                    "subject": "New File Alert",
                    "to": "user@example.com"
                },
                "runAfter": {},
                "type": "Microsoft.Outlook.SendEmail"
            }
        },
        "triggers": {
            "When_a_blob_is_added_or_modified": {
                "inputs": {
                    "parameters": {
                        "blobPath": "mycontainer/{name}"
                    },
                    "serviceProviderConfiguration": {
                        "connectionName": "azureblob",
                        "operationId": "OnBlobCreatedOrModified"
                    }
                },
                "recurrence": {
                    "frequency": "Minute",
                    "interval": 5
                },
                "type": "ApiConnection"
            }
        }
    }
}
        </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Sécurité et Gestion -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#securitySection" aria-expanded="false" aria-controls="securitySection">
                    Sécurité et Gestion d'Azure
                </button>
            </h2>
            <div id="securitySection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Azure Security Center</strong> : Outil de gestion de la sécurité qui offre une vue centralisée pour surveiller la sécurité des ressources dans Azure et sur site. Azure Security Center fournit des recommandations de sécurité, détecte les menaces et les vulnérabilités, et aide à renforcer la posture de sécurité de vos ressources. Il intègre des fonctionnalités telles que la gestion des correctifs, l'évaluation de la conformité, et la détection des menaces en temps réel. Exemple d'utilisation :
                            <pre>
                            <code>
// Activer Azure Security Center sur un abonnement
az security auto-provisioning-setting update --name default --auto-provision "On"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Monitor</strong> : Plateforme de gestion des performances et de la disponibilité des applications en surveillant les applications, l'infrastructure, et les réseaux. Azure Monitor collecte et analyse les données de télémétrie pour fournir des insights sur la performance et la santé de vos ressources. Il inclut des fonctionnalités telles que les alertes, les tableaux de bord personnalisables, et l'intégration avec des outils de gestion des incidents comme Azure Log Analytics et Application Insights. Exemple d'utilisation :
                            <pre>
                            <code>
// Créer une alerte dans Azure Monitor
az monitor metrics alert create --name "HighCPUAlert" --resource-group "myResourceGroup" --scopes "/subscriptions/{subscription-id}/resourceGroups/{resource-group}/providers/Microsoft.Compute/virtualMachines/{vm-name}" --condition "avg Percentage CPU > 80" --description "Alert when CPU usage is over 80%"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Policy</strong> : Outil de gouvernance qui permet de créer des règles pour gérer et appliquer la conformité des ressources Azure. Azure Policy vous aide à garantir que vos ressources respectent les normes et les exigences de votre organisation en appliquant des politiques de conformité. Il permet de définir des règles pour des configurations spécifiques, de surveiller la conformité en temps réel, et de corriger automatiquement les ressources non conformes. Exemple d'utilisation :
                            <pre>
                            <code>
// Créer une politique pour interdire les ressources sans tags
az policy definition create --name "require-tags" --rules '{ "if": { "field": "tags", "exists": "false" }, "then": { "effect": "deny" } }' --mode "All"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Key Vault</strong> : Service pour la gestion centralisée des clés cryptographiques, des secrets et des certificats pour sécuriser vos données et applications. Azure Key Vault permet de stocker et de gérer des clés de chiffrement, des secrets (comme des mots de passe et des clés API), et des certificats SSL/TLS de manière sécurisée. Il offre des fonctionnalités telles que le contrôle d'accès basé sur les rôles, l'intégration avec les services Azure, et la gestion des versions des secrets. Exemple d'utilisation :
                            <pre>
                            <code>
// Créer un coffre-fort de clés Azure
az keyvault create --name "myKeyVault" --resource-group "myResourceGroup" --location "eastus"
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Backup</strong> : Service de sauvegarde des données qui assure la protection des fichiers, des serveurs et des machines virtuelles dans le cloud. Azure Backup offre une solution de sauvegarde simple et fiable pour protéger vos données contre les pertes et les corruptions. Il prend en charge la sauvegarde des machines virtuelles Azure, des bases de données SQL, des fichiers et dossiers, et des serveurs sur site. Il inclut des fonctionnalités telles que la gestion des politiques de sauvegarde, la restauration granulaire, et le chiffrement des données en transit et au repos. Exemple d'utilisation :
                            <pre>
                            <code>
// Configurer une sauvegarde pour une machine virtuelle Azure
az backup protection enable-for-vm --resource-group "myResourceGroup" --vault-name "myRecoveryServicesVault" --vm "myVM"
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Réseautage Azure -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#networkingSection" aria-expanded="false" aria-controls="networkingSection">
                    Réseautage dans Azure
                </button>
            </h2>
            <div id="networkingSection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Azure Virtual Network (VNet)</strong> : Service permettant de créer des réseaux privés dans Azure pour connecter les ressources et sécuriser le trafic réseau. Azure VNet permet de segmenter le réseau en sous-réseaux, de définir des règles de sécurité avec des groupes de sécurité réseau (NSG), et de configurer des routes personnalisées. Il prend en charge la connectivité hybride avec des réseaux locaux via des connexions VPN ou ExpressRoute, et permet l'intégration avec d'autres services Azure comme Azure Firewall et Azure Bastion. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'un VNet avec un sous-réseau
az network vnet create --name myVNet --resource-group myResourceGroup --address-prefix 10.0.0.0/16 --subnet-name mySubnet --subnet-prefix 10.0.1.0/24
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Load Balancer</strong> : Outil qui distribue le trafic entrant vers plusieurs ressources pour améliorer la disponibilité et la résilience des applications. Azure Load Balancer prend en charge les scénarios de répartition de charge pour les applications web, les services cloud, et les machines virtuelles. Il offre des fonctionnalités telles que la surveillance de la santé des instances, la répartition de charge basée sur des règles, et la prise en charge des protocoles TCP et UDP. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'un Load Balancer
az network lb create --resource-group myResourceGroup --name myLoadBalancer --sku Basic --frontend-ip-name myFrontEnd --backend-pool-name myBackEndPool
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Traffic Manager</strong> : Service de gestion du trafic réseau pour diriger les utilisateurs vers des points de terminaison optimaux en fonction des performances ou de la priorité. Azure Traffic Manager utilise des profils de routage pour distribuer le trafic en fonction de la latence, de la géographie, ou de la priorité des points de terminaison. Il permet d'améliorer la disponibilité des applications en redirigeant le trafic en cas de défaillance d'un point de terminaison et offre une intégration avec des services comme Azure App Service et Azure Functions. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'un profil Traffic Manager
az network traffic-manager profile create --name myTrafficManagerProfile --resource-group myResourceGroup --routing-method Performance --unique-dns-name myapptrafficmanager
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure VPN Gateway</strong> : Service pour établir une connexion VPN sécurisée entre des réseaux locaux et Azure. Azure VPN Gateway prend en charge les connexions VPN de site à site, de point à site, et les connexions VPN inter-réseaux virtuels. Il offre des options de chiffrement et d'authentification robustes pour sécuriser les communications et permet de configurer des passerelles VPN redondantes pour une haute disponibilité. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'une passerelle VPN
az network vnet-gateway create --resource-group myResourceGroup --name myVpnGateway --vnet myVNet --public-ip-address myPublicIP --gateway-type Vpn --vpn-type RouteBased --sku VpnGw1 --no-wait
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure CDN</strong> : Réseau de distribution de contenu (CDN) permettant de délivrer des contenus rapidement et efficacement à des utilisateurs dans le monde entier. Azure CDN met en cache les contenus statiques comme les images, les vidéos, et les fichiers JavaScript à des emplacements stratégiques pour réduire la latence et améliorer les performances de chargement. Il offre des fonctionnalités telles que la gestion des règles de mise en cache, la protection contre les attaques DDoS, et l'intégration avec des services comme Azure Storage et Azure Media Services. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'un profil CDN
az cdn profile create --name myCdnProfile --resource-group myResourceGroup --sku Standard_Microsoft
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section Développement et IA -->
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#devAISection" aria-expanded="false" aria-controls="devAISection">
                    Développement et IA sur Azure
                </button>
            </h2>
            <div id="devAISection" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <ul class="list-group">
                        <li class="list-group-item">
                            <strong>Azure Machine Learning</strong> : Plateforme pour entraîner, déployer et gérer des modèles d'apprentissage automatique à grande échelle dans le cloud. Azure Machine Learning offre des outils pour le développement de modèles, y compris des notebooks Jupyter, des environnements de développement intégrés (IDE) et des frameworks populaires comme TensorFlow et PyTorch. Il permet l'automatisation des workflows de machine learning avec des pipelines, la gestion des expériences, et le suivi des modèles. Il offre également des fonctionnalités de déploiement pour mettre les modèles en production via des conteneurs ou des services web. Exemple d'utilisation :
                            <pre>
                            <code>
/paz ml workspace create --name myMLWorkspace --resource-group myResourceGroup --location eastus
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Cognitive Services</strong> : Collection d'API permettant d'ajouter des fonctionnalités d'IA, comme la reconnaissance vocale et visuelle, dans vos applications. Azure Cognitive Services inclut des services pour la vision par ordinateur, la reconnaissance vocale, la compréhension du langage naturel, et l'analyse des sentiments. Ces services peuvent être intégrés facilement dans des applications pour ajouter des capacités d'IA sans nécessiter de compétences approfondies en machine learning. Exemple d'utilisation :
                            <pre>
                            <code>
// Utilisation de l'API de reconnaissance faciale d'Azure Cognitive Services
az cognitiveservices account create --name myCognitiveService --resource-group myResourceGroup --kind Face --sku S0 --location eastus
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Bot Service</strong> : Plateforme pour créer des bots intelligents qui interagissent avec les utilisateurs via différents canaux comme Teams, Skype, ou des sites web. Azure Bot Service permet de développer, tester et déployer des bots en utilisant des frameworks comme Bot Framework SDK. Il offre des fonctionnalités pour la gestion des dialogues, l'intégration avec des services de langage naturel comme LUIS (Language Understanding), et la connexion à divers canaux de communication pour une interaction omnicanal. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'un bot avec Azure Bot Service
az bot create --resource-group myResourceGroup --name myBot --kind webapp --location eastus --sku S1 --appid myAppId --password myAppPassword
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure DevTest Labs</strong> : Service pour configurer rapidement des environnements de test et de développement en fonction des besoins des développeurs. Azure DevTest Labs permet de créer des environnements de développement et de test préconfigurés avec des machines virtuelles, des réseaux et des ressources de stockage. Il offre des fonctionnalités pour la gestion des coûts, l'automatisation des tâches de déploiement, et l'intégration avec des outils de CI/CD pour accélérer le cycle de développement. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'un lab DevTest
az lab create --resource-group myResourceGroup --name myDevTestLab
                                </code>
                            </pre>
                        </li>
                        <li class="list-group-item">
                            <strong>Azure Logic Apps</strong> : Plateforme low-code pour automatiser des processus métiers via des workflows qui intègrent divers services et systèmes. Azure Logic Apps permet de concevoir des workflows visuellement en utilisant une interface graphique et de connecter facilement des services tels que Office 365, Dynamics 365, Salesforce, et bien d'autres. Il prend en charge des déclencheurs et des actions basés sur des événements pour automatiser des processus métier complexes. Il offre également des fonctionnalités pour la gestion des erreurs, la surveillance des workflows, et l'intégration avec des services de sécurité et de conformité. Exemple d'utilisation :
                            <pre>
                            <code>
// Création d'une Logic App pour envoyer un email lorsqu'un fichier est ajouté à un Blob Storage
{
    "definition": {
        "$schema": "https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#",
        "actions": {
            "Send_an_email": {
                "inputs": {
                    "body": "A new file has been added to the Blob Storage.",
                    "subject": "New File Alert",
                    "to": "user@example.com"
                },
                "runAfter": {},
                "type": "Microsoft.Outlook.SendEmail"
            }
        },
        "triggers": {
            "When_a_blob_is_added_or_modified": {
                "inputs": {
                    "parameters": {
                        "blobPath": "mycontainer/{name}"
                    },
                    "serviceProviderConfiguration": {
                        "connectionName": "azureblob",
                        "operationId": "OnBlobCreatedOrModified"
                    }
                },
                "recurrence": {
                    "frequency": "Minute",
                    "interval": 5
                },
                "type": "ApiConnection"
            }
        }
    }
}
                                </code>
                            </pre>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
<p>&nbsp;</p>
<p class="h4">
    <br /><br /><br /><br />Fin
</p>